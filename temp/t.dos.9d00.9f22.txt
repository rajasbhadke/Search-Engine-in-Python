**********************************
*                                *
* ADDRESSES REFERRED TO BY DOS   *
*                                *
**********************************



*--------------------------------*
*      ZERO-PAGE ADDRESSES       *
*--------------------------------*

CH = $24 ;OFFSET FROM LEFT EDGE OF WINDOW
;TO NEXT CHR POS'N ON SCRN LINE.
;(RANGE:  $00-$23.)
PT2BTBUF = $26 ;PTR ($26,$27) TO TARGET BUF USED
;WHEN READING IN DOS DURING BOOT.
HOLDNIBL = $26 ;TEMP REG USED FOR HOLDING TWO-
;ENCODED NIBBLES WHEN WRITING
;A SECTOR DURING RWTS'S FORMAT OR
;WRITE OPERATIONS.
PROSCRTH = $26 ;TEMP REG USED FOR:
;- DECODING ODD/EVEN ADDR FIELD
;  BYTES.
;- CNTR AND INDEX TO RWTS BUFFERS
;  (1 & 2) WHEN POSTNIBBLING.
;- CNTR FOR # OF CHANCES TO FIND
;  THE CORRECT ADDR PROLOGUE.
STPSDONE = $26 ;- CNTR FOR # OF HALFTRKS MOVED.
;- CURRENT DISTANCE (EXPRESSED IN
;  HALFTRACKS) FROM THE START OR
;  DESTINATION HALFTRACK POS'NS.
FRMTSLOT = $27 ;SLOT * 16 USED TO INDEX DRIVE
;BASE ADDRESSES.
HOLDPRES = $27 ;HOLDS CURRENT HALFTRACK POSITION
;WHEN SEEKING.
CKSUMCAL = $27 ;RUNNING CHKSUM CALCULATION USED
;WHEN READING ODD-EVEN ENCODED
;ADDRESS FIELD BYTES.
BASL = $28 ;PTR ($28,$29) TO THE LEFT END OF
;THE SCREEN LINE.
DESTRK = $2A ;DESTINATION HALFTRACK POS'N WHEN
;SEEKING.
SLT16ZPG = $2B ;SLOT*16 USED TO INDEX DRIVE
;FUNCTIONS.
CKSUMDSK = $2C ;DECODED CHECKUSM VAL READ FROM
;ADDR FIELD (RWTS).
SECDSK = $2D ;PHYS SEC # FOUND IN ADDR FIELD.
TRKDSK = $2E ;TRK # FOUND IN ADDR FIELD.
VOLDSK = $2F ;VOL # FOUND IN ADDR FIELD.
PROMPT = $33 ;PROMPT CHAR USED TO SIGNAL INPUT
;IS REQUIRED.  ALSO USED AS A FLG
;IN THE CMD PARSING & PROCESSING
;ROUTINES.
DRVZPG = $35 ;DENOTES DRIVE SELECTED:
;  NEG = DRIVE 1, POS = DRIVE 2.
CSW = $36 ;MAIN OUTPUT HOOK (ALSO KNOWN AS
;THE CHARACTER OUTPUT SWITCH).
;PTR ($36,$37) TO DEVICE/ROUTINE
;WHICH HANDLES OUTPUT CHARACTERS.
KSW = $38 ;MAIN INPUT HOOK (ALSO KNOWN AS
;THE KEYBOARD SWITCH).
;PTR ($38,$39) TO DEVICE/ROUTINE
;THAT HANDLES INPUT CHARACTERS.
PTR2DCT = $3C ;PTR ($3C,$3D) TO RWTS'S DEVICE
;CHARACTERISTIC TABLE.
BOOTSEC = $3D ;PHYS SEC # WANTED WHEN BOOTING.
PTR2RDSC = $3E ;PTR ($3E,$3F) TO BOOT0'S READ-
;SECTOR SUBROUT'N (BTRDSEC, $CS5C
;WHERE S=SLOT #, NORMALLY=$C65C.)
PTR2BUF = $3E ;PTR ($3E,$EF) TO RWTS'S CURRENT
;DATA BUFFER.
HOLDAA = $3E ;- HOLDS  A CONSTANT ($AA) FOR
;  PROLOGUE AND EPILOGUE BYTES
;  USED WHEN FORMATTING.
;- ALSO USED AS A TEMP REG WHEN
;  CREATING ODD-EVEN ENCODED BYTS
;  ASSOC WITH THE ADDR FIELD.
FRMTSEC = $3F ;HOLDS # OF SEC TO BE FORMATTED &
;ALSO ACTS AS CNTR FOR # OF SECS
;VERIFIED WHEN CHECKING TRK JUST
;FORMATTED.
A3L = $40 ;MULTIPURPOSE REG & PTR ($40,$41)
FRMTVOL = $41 ;VOL # TO WRITE WHEN FORMATTING.
A4L = $42 ;MULTIPURPOSE REG & PTR ($42,$43)
A5L = $44 ;MULTIPURPOSE REG & PTR ($44,$45)
FRMTKCTR = $44 ;TRK# TO WRITE/READ WHEN FORMAT-
;TING/VERIFYING. ALSO ACTS AS A
;CNTR OF THE # OF TRKS FORMATTED/
;VERIFIED.
SYNCNTR = $45 ;# OF SYNC BYTES 2 WRT BTWN SECS
;& DELAY CNTR TO LET SOME SYNCS
;PASS BY READ HEAD WHEN VERIFYING
;A TRK JUST FORMATTED.
MTRTIME = $46 ;MOTOR-ON-TIME COUNT ($46,$47).
;CNTR USED TO DETERMINE IF THE
;DRIVE MOTOR HAS BEEN ON LONG
;ENOUGH TO DO RELIABLE READING.
;THE MOTOR IS CONSIDERED TO BE UP
;TO SPEED AFTER APPROX. 1 SECOND
;(AT WHICH TIME, MTRTIME = 0000).
PTR2IOB = $48 ;PTR ($48,49) TO RWTS'S INPUT/
;OUTPUT BLOCK (IOB).
STATUS = $48 ;STATUS REGISTER SAVE AREA.
LOMEM = $4A ;PTR ($4A,$4B) 2 START OF INTEGER
;BASIC'S VARIABLE TABLE.
HIMEM = $4C ;PTR ($4C,$4D) TO END OF INTEGER
;BASIC PRGM.
TXTTAB = $67 ;PTR ($67,$68) TO START OF THE
;APPLESOFT PRGM TEXT. DEFAULTS TO
;$801 ON A COLDSTART (ONCE EXECU-
;TION FLOWS INTO APPLESOFT).
;PTR'S CONTENTS CAN BE CHANGED TO
;ACCOMMODATE THE LOADING OF AN
;APPLESOFT PRGM IN A NON-STANDARD
;POSITION.
VARTAB = $69 ;PTR ($69,$6A) TO START OF SIMPLE
;VARIABLE TABLE.
FRETOP = $6F ;PTR ($6F,$70) TO START OF FREE
;SPACE (LOCATED BTWN THE END OF
;THE VARIABLE TBL & THE START OF
;THE STRING VALUES).
MEMSIZ = $73 ;PTR ($73,$74) TO HIGHEST MEMORY
;LOCATION (PLUS 1) THAT IS AVAIL-
;ABLE TO AN APPLESOFT PRGM.  (NOT
;TO BE CONFUSED WITH THE END OF
;THE APPLESOFT PRGM). CAN ALSO BE
;EXPRESSED AS A PTR TO THE FIRST
;BYTE OF THE DOS BUFFER REGION.
CURLIN = $75 ;CURRENT APPLESOFT PROGRAM LINE
;NUMBER ( $75,$76).  USED BY DOS
;2 DETERMINE IF BASIC IS RUNNING.
;(CURLIN+1 CONTAINS AN $FF WHEN
;COMPUTER IS IN THE IMMED MODE.)
PRGEND = $AF ;PTR ($AF,$B0) 2 END OF APPLESOFT
;PRGM (PLUS 1) IF FP CMD WAS USED
;OR TO END OF PRGM (PLUS 2) IF A
;NEW CMD WAS USED.
INTPGMST = $CA ;PTR ($CA,$CB) TO START OF THE
;INTEGER PRGM.
INTVRLND = $CC ;INTEGER BASIC'S CURRENT END-OF-
;VARIABLE PTR ($CC,$CD).
PROTFLG = $D6 ;PRGM PROTECTION FLAG.
;IF PROTECTION FLAG IS ON (NEG),
;ALL APPLESOFT CMDS CAUSE A RUN &
;DOS'S SAVE CMD CAUSE A PHONY
;PROGRAM-TOO-LARGE ERROR MSG 2 BE
;GENERATED.
ERRFLG = $D8 ;ON-ERROR FLAG.  EQUALS $80 IF
;ON-ERR IS ACTIVE.
RUNMODE = $D9 ;INTEGER BASIC'S MODE FLAG.
;CONTAINS A NEG VALUE IF INTEGER
;IS IN THE DEFERRED MODE.


*--------------------------------*
*      PAGES TWO TO EIGHT        *
*--------------------------------*

BUF200 =  $200 ;THE INPUT BUFFER ($200-$2FF).
;(ALSO KNOWN AS KEYBOARD BUFFER.)

PG3DOSVT = $3D0       ;START OF PAGE-3 DOS VECTOR TBL.
RESETVEC = $3F2 ;RESET VECTOR.  CONTAINS ADDR OF
;ROUT'N WHERE EXECUT'N DIVERTS TO
;WHEN THE RESET KEY IS PRESSED.
VLDBYTE = $3F4 ;RESET VALIDATION BYTE.
;IF $3F3 EOR #$A5 IS NOT EQUAL TO
;$3F4, THEN DISK REBOOTS AND A
;COLDSTART IS DONE.  OTHERWISE,
;EXECUTION GOES TO THE ADDR IN
;$3F2/$3F3.

TRK4DRV1 = $478 ;BASE ADR USED TO REFERENCE THE
;LOCATION THAT CONTAINS THE LAST
;HALFTRACK ON WHICH DRIVE 1 WAS
;ALIGNED.
PRESTRK = $478 ;- CURRENT HALFTRACK NUMBER.
;- SAVE REG FOR WHOLE TRK# WANTED
;  WHEN HAVE TO GO RECALIBRATE.
TRK4DRV2 = $4F8 ;BASE ADR USED TO REFERENCE THE
;LOCATION THAT CONTAINS THE LAST
;HALFTRACK ON WHICH DRIVE 2 WAS
;ALIGNED.
RSEEKCNT = $4F8 ;CNTR FOR # OF RE-SEEKS ALLOWED
;BETWEEN RECALIBRATIONS (4 --> 1,
;DO RECALIBRATION WHEN CNTR = 0.)

READCNTR = $578 ;CNTR FOR # OF ATTEMPTS ALLOWED 2
;GET A GOOD ADDR OR DATA READ.
SLOTPG5 = $5F8 ;SLOT*16 USED WHEN DOS WAS BOOTED

SLOTPG6 = $678 ;SLOT*16 USED WHEN FORMATTING &
;WRITING.
RECLBCNT = $6F8 ;CNTR FOR # OF RECALIBRATIONS
;ALLOWED BEFORE RWTS GIVES UP.

BT1LDADR = $8FD ;BOOT1 LOAD ADDRESS ($8FD,$8FE).
;VARIES FROM $B600 TO $BF00.
;EVENTUALLY POINTS 2 THE START OF
;BOOT2 ($B700).
BT1PG2RD = $8FF ;INITIALLY CONTAINS # OF SECS TO
;READ IN WHEN EXECUTING BOOT1.
;ALSO DOUBLES AS LOGICAL SEC #.
;(VARIES FROM $09 --> $00 -->$FF)
;(SEE DISCUSSION IN FORMATTED
;DIS'MBLY "THE BOOT PROCESS".)


*--------------------------------*
*  RAM-BASED APPLESOFT ADDRESSES *
*             A(RAM)             *
*--------------------------------*
CLRFPRAM = $E65 ;ENTRY POINT TO CLEAR VARIABLES
;FROM A RAM-BASED APPLESOFT PRGM.
RUNFPRAM = $FD4 ;ENTRY POINT 2 EXECUTE RAM-BASED
;APPLESOFT PRGM.


*--------------------------------*
*        DOS BUFFER START        *
*--------------------------------*

DOSNMBF1 = $9CD3 ;ADDR OF FIRST DOS NAME BUFFER.


*--------------------------------*
*   DRIVE FUNCTION BASE ADDRS    *
*--------------------------------*
* NOTE:  THE ACTUAL ADDRESSES    *
* USED ARE DEPENDENT UPON WHICH  *
* SLOT HOUSES THE DSK CONTROLLER *
* CARD. (SEE COMMENTS IN ANY ONE *
* OF THE FORMATTED DISASSEMBLIES *
* OF RWTS FOR MORE DETAILS.)     *

MAG0FF = $C080 ;BASE ADDR TO TURN STEPPER MOTOR
;MAGNET ON OR OFF.
MTROFF = $C088 ;BASE ADDR TO TURN DRV MOTOR OFF.
MTRON = $C089 ;BASE ADR TO TURN DRV MOTOR ON.
SELDRV1 = $C08A ;BASE ADR TO SELECT DRIVE 1.
SELDRV2 = $C08B ;BASE ADR TO SELECT DRIVE 2.
Q6L = $C08C ;SHIFT BYTE IN OR OUT OF LATCH.
Q6H = $C08D ;LOAD LATCH FROM DATA BUS.
Q7L = $C08E ;PREPARE TO READ.
Q7H = $C08F ;PREPARE TO WRITE.

BTRDSEC = $C65C ;BOOT0'S READ SECTOR SUBROUTINE.
;(ACTUALLY=$CS5C, WHERE S=SLOT#.)


*--------------------------------*
*       APPLESOFT ADDRESSES      *
*--------------------------------*
RESTART = $D43C ;APLSFT BASIC'S WRMSTART ROUTINE.
SETLINKS = $D4F2 ;ROUT'N THAT CLEARS ALL VAR'BLES,
;RESETS THE STK PTR & RECALCS THE
;LINKS IN @ APPLESOFT PRGM LINE.
;(THIS ROUTINE IS WHAT ENABLES
;APLSFT PRGMS TO BE RELOCATABLE.)
SETZPTRS = $D665 ;APPLESOFT ROUTINE THAT SIMULATES
;CLEAR & RESTORE STATEMENTS.
NEWSTT = $D7D2 ;ROUTINE TO COLLECT & EXECUTE THE
;APPLESOFT PRGM STATEMENT.
BSCERHLR = $D865 ;BASIC'S ERROR-HANDLING ROUTINE.
BASICCLD = $E000 ;BASIC'S COLDSTART ROUTINE.


*--------------------------------*
*      MONITOR ROM ROUTINES      *
*--------------------------------*
OLDBRK = $FA59 ;DEFAULT BREAK INTERRUPT HANDLER.
INIT = $FB2F ;SCREEN INITIALIZATION ROUTINE.
;(SET FULL SCREEN TEXT.)
HOME = $FC58 ;BLANK OUT CURRENT SCROLL WINDOW
;& PUT THE CURSOR IN THE TOP LEFT
;CORNER OF THE WINDOW.  (DOES NOT
;RESET THE WINDOW SIZE.)
RDKEY = $FD0C ;REQUEST INPUT VIA INPUT HOOK.
KEYIN = $FD1B ;WAIT FOR INPUT FROM KEYBOARD.
PRBYTE = $FDDA ;PRINT CONTENTS OF (A) AS HX VAL.
COUT = $FDED ;ROUTE OUTPUT VIA THE OUTPUT HK.
COUT1 = $FDF0 ;MONITOR ROM (TRUE) OUTPUT HNDLR.
SETKBD = $FE89 ;SELECT KEYBOARD AS INPUT DEVICE.
INPORT = $FE8B ;ENTRY POINT TO SELECT INPUT
;DEVICE OTHER THAN KEYBOARD.
SETVID = $FE93 ;SELECT SCREEN AS OUTPUT DEVICE.
OUTPORT = $FE95 ;ENTRY POINT TO SELECT OUTPUT
;DEVICE OTHER THAN SCREEN.
MONRTS = $FF58 ;AN RTS INSTRUC LOC'D IN MONITOR
;ROM. MANY RELOCATABLE PGMS "JSR"
;TO HERE IN ORDER TO LOAD UP THE
;STACK WITH THE ADDR OF THE "JSR"
;SO THEY CAN FIND OUT THE PRGM'S
;PRESENT LOCATION.
MON = $FF65 ;NORM ENTRY ROUTE 2 MONITOR ROM.
;("CALL -151" GOES HERE.)


* ====================================
* RELOCATABLE ADDRESS CONSTANTS TABLE.
*          ($9D00 - $9D0F)
* (ADRS CAN BE CHANGED TO POINT TO
* CUSTOMIZED ROUTINES, TABLES, ETC.)
* ====================================

ADOSFNB1 DA DOSNMBF1 ;PTS TO FIRST DOS BUFFER AT ITS
;FILE NAME FIELD.
ADINPTCP DA INPTINCP ;PTS TO DOS'S INPUT INTERCEPT
;ROUTINE.
ADOPUTCP DA OPUTINCP ;PTS TO DOS'S OUTPUT INTERCEPT
;ROUTINE.
ADRPFNBF DA PRIMFNBF ;PTS TO PRIMARY FILENAME BUFFER.
ADRSFNBF DA SCNDFNBF ;PTS TO SECONDARY FILENAME BUFFER.
ADLENADR DA LENADRBF ;PTS TO 2-BYTE BUF THAT RECEIVES
;BLOAD ADR & LENGTH READ FROM DSK
ADOSTART DA ADOSFNB1 ;PTS TO 1RST BYTE OF DOS.
ADFMPARM DA OPCODEFM ;PTS TO FM PARAMETER LIST.


*=====================================
* TABLE OF OUTPUT HANDLER ENTRY POINTS
*          ($9D10 - $9D1D)
* (ADR-1 OF ROUT'NS WHICH HANDLE PRINT
* STATEMENTS CONTAINING DOS CMDS.)
*=====================================

OUTHNDTB DA OPUTHDL0-1 ;EVALUATE START OF INPUT LINE.
 DA OPUTHDL1-1 ;COLLECT THE DOS COMMAND.
 DA OPUTHDL2-1 ;PRINT A <CR> AND RETURN.
 DA OPUTHDL3-1 ;PROCESS THE INPUT INFORMATION.
 DA OPUTHDL4-1 ;WRITE DATA TO DISK.
 DA OPUTHDL5-1 ;ANALYZE 1RST CHR OF DATA FRM DSK
 DA OPUTHDL6-1 ;IGNORE INPUT PROMPT ("?").


*=======================================
*   COMMAND HANDLER ENTRY POINT TABLE
*           ($9D1E - $9D55)
* ALL ADRS ARE ONE LESS THAN THE ACTUAL
* ENTRY POINTS BECAUSE THESE ROUT'NS ARE
* ENTERED VIA A "STACK JUMP".  IF YOU
* CREATE A NEW DOS CMD, PLACE THE ADR-1
* OF THE NEW CMD IN THE FOLLOWING TABLE.
* (ALSO MAKE SURE THAT THE FIRST CMD IN
* THE TABLE CAN CREATE A NEW FILE.)
* SOME AUTHORS DISABLE SPECIFIC DOS
* CMDS BY POINTING THE CMD'S TABLE ADR
* AT DOS'S COLDSTART ROUTINE OR BY
* PLACING AN "RTS" OPCODE AT THE CMD'S
* ENTRY POINT.
*=======================================

CMDTBL DA CMDINIT-1 ;        $A54F-1
 DA CMDLOAD-1 ;        $A413-1
 DA CMDSAVE-1 ;        $A397-1
 DA CMDRUN-1 ;        $A4D1-1
 DA CMDCHAIN-1 ;        $A4F0-1
 DA CMDELETE-1 ;        $A263-1
 DA CMDLOCK-1 ;        $A271-1
 DA CMDUNLOK-1 ;        $A275-1
 DA CMDCLOSE-1 ;        $A2EA-1
 DA CMDREAD-1 ;        $A51B-1
 DA CMDEXEC-1 ;        $A5C6-1
 DA CMDWRITE-1 ;        $A510-1
 DA CMDPOSN-1 ;        $A5DD-1
 DA CMDOPEN-1 ;        $A2A3-1
 DA CMDAPPND-1 ;        $A298-1
 DA CMDRENAM-1 ;        $A281-1
 DA CMDCATLG-1 ;        $A56E-1
 DA CMDMON-1 ;        $A233-1
 DA CMDNOMON-1 ;        $A23D-1
 DA CMDPR-1 ;        $A229-1
 DA CMDIN-1 ;        $A22E-1
 DA CMDMXFIL-1 ;        $A251-1
 DA CMDFP-1 ;        $A57A-1
 DA CMDINT-1 ;        $A59E-1
 DA CMDBSAVE-1 ;        $A331-1
 DA CMDBLOAD-1 ;        $A35D-1
 DA CMDBRUN-1 ;        $A38E-1
 DA CMDVERFY-1 ;        $A27D-1


*===========================================
*   ACTIVE BASIC ENTRY POINT VECTOR TABLE
*             ($9D56 - $9D61)
* (NOTE:  TBL CUTOMIZED BY DOS ACCORDING TO
* THE CURRENT VERSION OF BASIC THAT IS BEING
* USED.  ADRS SHOWN AS OPERANDS BELOW,
* ASSUME THAT APPLESOFT BASIC IS ACTIVE.)
*===========================================

CHAINTRY DA RUNFPROM ;ADR OF CHAIN ENTRY PT TO BASIC.
RUNTRY DA RUNFPROM ;ADR OF BASIC'S RUN CMD.
ADBSCERR DA BSCERHLR ;ADR OF BASIC'S ERROR HANDLER.
TOCLDVEC DA BASICCLD ;ADR OF BASIC'S COLD START ROUT'N
TOWRMVEC DA RESTART ;ADR OF BASIC'S WARM START ROUT'N
RLOCNTRY DA SETLINKS ;ADR OF ROUT'N THAT ENABLES BASIC
;PRGMS TO BE RELOCATABLE.


*====================================
* IMAGE OF INTEGER BASIC'S ENTRY
* POINT VECTOR TABLE ($9D62 - $9D6B).
*====================================

IMGINTV DA $E836
 DA $A4E5
 DA $E3E3
 DA $E000
 DA $E003


*=======================================
* IMAGE OF ROM APPLESOFT BASIC'S ENTRY
* POINT VECTOR TABLE ($9D6C - $9D77).
*=======================================

IMGFPV DA RUNFPROM
 DA RUNFPROM
 DA BSCERHLR
 DA BASICCLD
 DA RESTART
 DA SETLINKS


*========================================
* IMAGE OF RAM APPLESOFT BASIC'S  ENTRY
* POINT VECTOR TABLE ($9D78 - $9D83).
* (NOTE: A(RAM) REFERS TO A DISK-BASED
* VERSION OF APPLESOFT BASIC THAT IS
* HOUSED ON THE "SYSTEMS MASTER" DISK.)
*========================================

IMGARAMV DA FPRAMRUN
 DA FPRAMRUN
 DA $1067
 DA $9D84
 DA $C3C
 DA $CF2


*=================================
* DOS'S COLD START ROUTINE.
* (PS. DON'T CONFUSE WITH BASIC'S
* COLD START ROUTINE - BASICCLD.)
*=================================

* GET SLOT & DRV #'S & STORE THEM AS
* DEFAULT VALS IN CASE NO SUCH PARMS
* WERE ISSUED WITH THE COMMAND.

DOSCOLD LDA IBSLOT ;SLOT# * 16 FROM RWTS'S IOB TBL.
 LSR  ;DIVIDE BY 16.
 LSR
 LSR
 LSR
 STA SLOTPRSD ;PUT SLOT IN PARSED TABLE.
 LDA IBDRVN ;DRV # FROM RWTS'S IOB.
 STA DRVPRSD ;PUT DRIVE # IN PARSED TABLE.

* CHK WHICH BASIC IS IN ROM.

 LDA BASICCLD ;SET IDENTIFYING BYTE WITH
 EOR #$20 ;$20 = INTEGER OR $40 = A(ROM).
 BNE ISFPROM ;BRANCH IF APPLESOFT IS IN ROM.

* INTEGER BASIC IS ACTIVE.

ISINT STA ACTBSFLG ;SET ACTIVE BASIC FLAG
;TO DENOTE INTEGER (#$00).

* COPY IMAGE OF INTEGER BASIC'S
* ENTRY POINT VECTOR TABLE TO THE
* ACTIVE BASIC ENTRY VECTOR TABLE.

 LDX #10
INT2BSIC LDA IMGINTV-1,X
 STA CHAINTRY-1,X
 DEX
 BNE INT2BSIC ;10 BYTES TO COPY (10 --> 1).
 JMP BYPASWRM

* COPY IMAGE OF APPLESOFT'S ENTRY
* POINT VECTOR TABLE TO THE ACTIVE
* BASIC ENTRY POINT VECTOR TABLE.

ISFPROM LDA #$40 ;SET ACTIVE BASIC FLAG TO #$40
 STA ACTBSFLG ;SO SIGNAL APPLESOFT ROM.
 LDX #12
AROM2BSC LDA IMGFPV-1,X
 STA CHAINTRY-1,X
 DEX
 BNE AROM2BSC
BYPASWRM SEC ;(C) = 1, SIGNAL FOR COLDSTART.
;(C) = 0, SIGNAL FOR WARMSTART.
 BCS CMWRMCLD ;FORCE BRANCH TO BYPASS PART OF
;THE WARMSTART ROUTINE.


*=================================
* DOS'S WARMSTART ROUTINE.
* (PS. DON'T CONFUSE WITH BASIC'S
* WARMSTART ROUTINE - RESTART.)
*=================================

DOSWARM LDA ACTBSFLG ;SEE WHICH LANGUAGE IS UP.
 BNE CKBASIC ;IF A(ROM), #$40 OR A(RAM), #$80.

* INTEGER WAS UP.

 LDA #$20 ;(A) = OPCODE FOR "JSR" INSTRUC.
 BNE DTRMNBSC ;ALWAYS.


* ACTIVE BASIC FLAG DENOTED THAT A
* VERSION OF APPLESOFT WAS ACTIVE,
* SO NOW CHECK IF DEALING WITH
* A(RAM) OR A(ROM).

CKBASIC ASL ;MULTIPLY CODE TIMES 2.
 BPL FORWARM ;BRANCH IF A(RAM).
;(IE. A(RAM) YEILDS $40 * 2 = $80
;& A(ROM) YEILDS $80 * 2 = $00.)

* USING A(ROM).

 LDA #$4C ;(A) = OPCODE FOR "JMP" INSTRUC.
DTRMNBSC JSR SETROM ;GO TEST CARD OR MOTHERBOARD TO
;INSURE THAT DEVICE CONTAINING
;ROM VERSION WE WANT IS SELECTED.
FORWARM CLC ;(C) = 0, SIGNAL FOR WARMSTART.
CMWRMCLD PHP ;SAVE (C) DENOTING WARM OR COLD.
 JSR INITIOHK ;INITIALIZE THE I/O HOOKS SO THAT
;DOS INTERCEPTS ALL IN/OUTPUT.
 LDA #0
 STA CIOCUMUL ;SIMULATE A "NOMON" COMMAND.
;NOTE: CAN "NOP" OUT THIS INSTRUC
;TO DEFEAT "NOMONCIO" WHEN COLD-
;OR WARMSTARTING.
 STA OPUTCOND ;SET CONDITION 0.
 PLP ;GET SAVED STATUS BACK OFF STK &
 ROR ;ROTATE (C) INTO HI BIT OF (A) TO
 STA CONDNFLG ;SET CONDNFLG = $00 FOR WARMSTART
;OR CONDNFLG = $80 FOR COLDSTART.
 BMI LANGCOLD ;BRANCH IF DOING COLDSTART.

LANGWARM JMP (TOWRMVEC) ;JMPS TO BASIC'S WARMSTART ROUT'N
;(RESTART) AT $D43C.

LANGCOLD JMP (TOCLDVEC) ;JMPS TO BASIC'S COLDSTART ROUT'N
;(BASICCLD) AT $E000.


*=================================
*  INITIAL PROCESSING WHEN FIRST
*  KEYBOARD INPUT REQUEST IS MADE
*  BY BASIC AFTER A COLDSTART.
*=================================

* TEST IF USING A(RAM) OR NOT.
* ON ENTRY, (A) = CONTENTS OF CONDNFLG.
*               = $00 = WARM START.
*               = $01 = READING.
*               = $80 = COLD START.
*               = $C0 = USING A(RAM).

KEYCOLD ASL ;(A) * 2 TO DROP OUT HI BIT.
 BPL SKPDARAM ;BRANCH IF NOT USING A(RAM).
 STA ACTBSFLG ;USING A(RAM) - WAS LOADED BY
;               INTEGER BASIC ROM
;             - ACTV BSC FLG=$80

* COPY IMAGE OF A(RAM)'S ENTRY
* POINT VECTOR TABLE TO THE
* ACTIVE BASIC ENTRY POINT VECTOR
* TABLE.

 LDX #12
ARAM2BSC LDA IMGARAMV-1,X
 STA CHAINTRY-1,X
 DEX
 BNE ARAM2BSC

* BLANK OUT THE PRIMARY FILENAME
* BUFFER TO MAKE SURE A "HELLO"
* FILE WON'T BE RUN.

 LDX #29 ;30 BYTES TO BLANK (29 --> 00).
BLNKPRIM LDA SCNDFNBF,X ;COPY BLANK SECONDARY TO PRIMARY.
 STA PRIMFNBF,X
 DEX
 BPL BLNKPRIM

* BUILD DOS BUFS & SET CONDITION.

SKPDARAM LDA MAXDFLT ;SET MXFILVAL TO DEFAULT VAL OF 3
 STA MXFILVAL ;NOTE: DEFAULT VAL CAN BE CHANGED
;BY SETTING MAXDFLT BTW'N 1 - 16
;AND THEN INITING A DISK.
 JSR BILDBUFS ;GO BUILD THE DOS BUFFERS.
 LDA EXECFLAG ;CHK IF AN EXEC FILE IS RUNNING.
 BEQ SKPDEXEC ;BRANCH IF NOT EXECING.

 PHA ;YES - WE ARE EXECING.
 JSR PT2EXEC ;GET ADR OF BUF WE'RE EXECING IN.
 PLA ;RETRIEVE EXEC FLG FROM STK.
 LDY #0 ;RESERVE DOS BUFFER FOR EXECING
 STA (A3L),Y ;IN CASE WE WANT TO MODIFY DOS TO
;EXEC ON THE BOOT?

SKPDEXEC JSR RESTAT0 ;SET CONDNFLG=0 SO SIGNAL FILE
;NOT BEING READ.
;RESET OPUTCOND=0 (TO SIGNAL WANT
;TO EVALU8 START OF LINE ON RTN).

* CHECK IF DISK WAS JUST BOOTED.
* (IF JUST BOOTED DISK, NDX2CMD
* CONTAINS A $00 WHICH WAS ETCHED
* ON THE DISK WHEN THE DISK WAS
* ORIGINALLY INITED.)

 LDA NDX2CMD ;WAS LAST CMD AN "INIT"?
 BNE OLDBOOT ;NO - TAKE BRANCH.

* DISK WAS JUST BOOTED SO COPY IMAGE
* OF DOS'S ENTRY POINT VECTOR TABLE
* TO PAGE 3.

 LDX #47 ;48 BYTES TO COPY (47 --> 0).
STOR3DOS LDA IMGDOSVT,X ;COPY IMAGE TO PAGE 3.
 STA PG3DOSVT,X
 DEX
 BPL STOR3DOS

* PROGRAM THE RESET KEY TO POINT AT
* DOS'S WARMSTART ROUTINE.
*
* NOTE THAT THE RESET KEY CAN BE
* PROGRAMMED TO PT AT ANY LOCATION
* SIMPLY BY PUTTING THE ADR OF THE
* TARGET ROUTINE (IN LOW/HI FORMAT)
* IN $3F2/$3F3.  NEXT, EOR THE
* CONTENTS OF $3F3 WITH THE NUMBER
* #$A5 AND PUT THE RESULT IN $3F4.
* (IF $3F3 EOR #$A5 < > $3F4, THEN
* DISK REBOOTS & A COLDSTART IS DONE.)

 LDA IMGDOSVT+2 ;WRITE OVER OLD (OUT-DATED) IMAGE
 STA RESETVEC+1 ;WHICH CONTAINED A "JSR MON"
 EOR #$A5 ;INSTRUC APPLIC TO NON-AUTOSTART.
 STA VLDBYTE ;SET VALIDATION (POWER UP) BYTE.
 LDA IMGDOSVT+1
 STA RESETVEC

* SET THE COMMAND INDEX TO RUN
* THE "HELLO" FILE.

 LDA #6 ;CMD INDEX FOR "RUN".
;(CAN BE CHANGED TO "BRUN", ETC.)
 BNE DOPENDNG ;ALWAYS.

* CHECK IF A COMMAND IS PENDING.

OLDBOOT LDA NEXTCMD
 BEQ NOPEND ;NO CMD PENDING.

* GO DO THE PENDING COMMAND.  IF THE
* DISK WAS JUST BOOTED, THEN RUN THE
* "HELLO" FILE.  NOTE THAT THE ACTUAL
* NAME OF THE HELLO FILE RESIDES IN
* THE PRIMARY FILENAME BUFFER.  IT
* WAS WRITTEN TO THE DISK AS PART OF
* THE DOS IMAGE WHEN THE DISK WAS INITED.
* THERE4, IF YOU WANT TO CHANGE THE
* NAME OF THE HELLO FILE, YOU MUST:
*  (1) CHNG NAME IN FILENAME FIELD
*      OF DIRECTORY SEC. (EASIEST JUST
*      TO USE THE RENAME CMD.)
*  (2) ZAP PRIMARY NAME BUF ON DISK
*      (TRK$01/SEC$09/OFFSETS$75-$92).

DOPENDNG STA NDX2CMD ;SET CMD INDEX & GO DO CMD.
 JMP DODOSCMD
NOPEND RTS


*=================================
* IMAGE OF DOS VECTOR TABLE.
* (COPIED TO PAGE 3, $3D0 - $3FF.)
*=================================

;      PAGE-3 ADDR & FUNCTION

IMGDOSVT JMP DOSWARM ;$3D0 - GO TO DOS'S WARM START
;ROUTINE.  LEAVE PGRM INTACT.
 JMP DOSCOLD ;$3D3 - GO TO DOS'S COLD START
;ROUT'N. RESET HIMEM, REBUILD DOS
;BUFS & WIPE OUT PRGM.
 JMP FMXTNTRY ;$3D6 - ALLOW USER TO ACCESS FM
;VIA HIS OWN ASSEMBLY LANG PRGMS.
 JMP ENTERWTS ;$3D9 - ALLOW USER TO ACCESS RWTS
;VIA HIS OWN ASSEMBLY LANG PRGMS.
 LDA ADFMPARM+1 ;$3DC - LOCATE FM PARAMETER LIST.
 LDY ADFMPARM
 RTS

 LDA ADRIOB+1 ;$3E3 - LOCATE RWTS'S I/O BLOCK.
 LDY ADRIOB
 RTS

 JMP INITIOHK ;$3EA - PT I/O HOOKS AT DOS'S
;INTERCEPT HANDLERS.
 NOP
 NOP
 JMP OLDBRK ;$3EF - GOES TO MONITOR'S ROUTINE
;WHICH HANDLES "BRK" INSTRUC'S.
 JMP MON ;AFTER THIS INSTRUCTION IS COPIED
;TO PAGE 3 (AT $3F2 - $3F4), THE
;ROUTINE AT $9E30 OVERWRITES THE
;PAGE-3 IMAGE 2 PROGRAM THE RESET
;KEY. THIS OVERWRITTING IS DONE 2
;ACCOMMODATE NEWER "AUTOSTART"
;ROM USED IN THE APPLE II+, IIE &
;IIC MACHINES.  THE PAGE-3 LOC'S
;ARE DESCRIBED BELOW:
;$3F2/$3F3 - ADR OF RESET HNDLING
;ROUT'N (IN LOW/HI FORMAT).
;NORMALLY=ADR OF DOSWARM ($9DBF).
;$3F4 - IMG OF VALIDATION BYTE.
;NORMALLY CONTAINS #$38 CAUSE:
;            #$9D EOR #$A5 = #$38.

 JMP MONRTS ;$3F5 - DISABLE &-VECTOR.
 JMP MON ;$3F8 - LET CTL-Y ENTER MONITOR.
 JMP MON ;$3FB - HNDL NON-MASK INTERUPTS.
 DA MON ;ROUT'N 2 HNDL MASKABLE INTERUPTS


*==================================
* DOS'S INPUT INTERCEPT ROUTINE.
* (INTERCEPTS ALL INPUT FROM
* KEYBOARD OR DISK.)
*==================================

INPTINCP JSR PREP4DOS ;SAVE THE REGS & RESTORE I/O HKS
;TO PT TO THE TRUE I/O HANDLERS.
;ADJUST STK PTR & SAVE IT SO WE
;CAN LATER RTN 2 THE ROUTINE THAT
;CALLED ROUTINE THAT CONTAINED
;THE "JSR PREP4DOS" INSTRUCTION.
 LDA CONDNFLG ;TEST IF DOING WARMSTART.
 BEQ INPUTWRM ;YES - BRANCH IF WARM.

* READING FILE OR COLDSTARTING.

 PHA ;SAVE THE CONDITION FLAG.
 LDA ASAVED ;GET THE SUBSTITUTE CURSOR & PUT
 STA (BASL),Y ;IT BACK ON THE SCREEN.
 PLA ;GET CONDITION FLAG BACK IN (A).
 BMI INPUTCLD ;BRANCH FOR COLD.
 JMP READTEXT ;READ FILE BYTE.

* DOING A COLDSTART.

INPUTCLD JSR KEYCOLD ;SET IMPORTANT PAGE 3 VECTORS.
;SET MXFILVAL=3 & BUILD DOS BUFS.
;SET WARMSTART FLAG.
;EXECUTE PENDING COMMAND.
 LDY CH ;GET HORZ CURSOR POS'N.
 LDA #$60 ;GET CURSOR.
 STA (BASL),Y ;REINSTATE CURSOR ON SCREEN.

* USING WARMSTART STATUS.
* AT THIS POINT IN TIME, BOTH
* CONDNFLG & OPUTCOND = 0 FOR
* WARM- & COLDSTARTS.

INPUTWRM LDA EXECFLAG ;ARE WE EXECING?
 BEQ INPTNOXC ;NO.
 JSR READEXEC ;YES - GO READ AN EXEC FILE BYTE.
INPTNOXC LDA #3 ;SET OUTPUT CONDITION = 3 CAUSE
 STA OPUTCOND ;WANT TO PROCESS INPUT INFO.
 JSR RESTOREG ;RESTORE (A), (Y) & (X) REGS.
 JSR TOTRUIN ;GET CHAR & PUT IT ON SCREEN VIA
;THE TRUE OUTPUT HANDLER (COUT1).
 STA ASAVED ;SAVE CHAR & (X).
 STX XSAVED
 JMP DOSEXIT ;EXIT DOS.

TOTRUIN JMP (KSW) ;JUMP TO THE TRUE INPUT HANDLER.


*=================================
* DOS'S OUTPUT INTERCEPT ROUTINE.
* (INTERCEPTS ALL OUPUT TO SCREEN
* OR OTHER PERIPHERALS.)
*=================================

OPUTINCP JSR PREP4DOS ;SAVE REGS & RESTORE I/O HKS 2 PT
;2 TRUE I/O HANDLERS.  ADJUST STK
;PTR & SAVE IT SO CAN LATER RTN
;TO THE ROUTINE THAT CALLED THE
;ROUTINE THAT CONTAINED THE
;"JSR PREP4DOS" INSTRUCTION.

* USE CURRENT OPUTCOND TO INDEX
* TABLE CONTAINING ADDRS (MINUS 1)
* OF THE OUTPUT CONDITION HANDLERS.
* DO A "STACK JUMP" TO THE APPROPRIATE
* HANDLER.

 LDA OPUTCOND
 ASL ;TIMES 2 CAUSE 2 BYTES / ADDRESS.
 TAX ;SET (X) TO INDEX TABLE OF ADRS.
 LDA OUTHNDTB+1,X ;PUT ADR OF OUTPUT HNDLR ON STK
 PHA  ;(HI BYTE FIRST) & THEN DO A
 LDA OUTHNDTB,X ;"STACK JUMP" TO THE APPROPRIATE
 PHA ;HANDLER.
 LDA ASAVED ;GET CHAR TO BE PRINTED.
 RTS ;EXECUTE THE STACK JUMP.


*================================
* PREPARE FOR PROCESSING BY DOS.
* SAVE THE REGS & RESET THE I/O
* HOOKS TO POINT TO THE TRUE I/O
* HANDLERS.
*================================

PREP4DOS STA ASAVED ;SAVE (A), (Y) & (X) REGS.
 STX XSAVED
 STY YSAVED
 TSX ;ADJUST STK PTR & SAVE IT SO WHEN
 INX ;WE LATER RESTORE IT & HIT AN
 INX ;RTS, WE CAN RTN 2 ROUTINE THAT
 STX STKSAVED ;CALLED ROUTINE THAT CONTAINED
;THE "JSR PREP4DOS" INSTRUCTION.

* DISCONNECT DOS - THIS ENTRY POINT
* IS FREQUENTLY USED BY ASSEMBLY
* LANGUAGE PROGRAMMERS TO DISCONNECT
* DOS COMPLETELY.

UNCONDOS LDX #3 ;RESTORE THE I/O HKS TO PT TO THE
;TRUE I/O HANDLERS, EX:
SETRUHKS LDA CSWTRUE,X ;   KSWTRUE: KEYIN --> KSW: KEYIN
 STA CSW,X ;   CSWTRUE: COUT1 --> CSW: COUT1
 DEX
 BPL SETRUHKS ;4 BYTES (0 TO 3) TO MOVE.
 RTS


*=================================
*        OUTPUT HANDLER 0.
*    (EVALUATE START OF LINE.)
*=================================

OPUTHDL0 LDX RUNTRUPT ;CONTAINS A NONZERO VALUE IF RUN
 BEQ NONTRUPT ;CMD WAS INTERRUPTED TO DO A LOAD
 JMP FINSHRUN ;FINISH OFF THE RUN COMMAND.

* FILE NOT BEING READ.

NONTRUPT LDX CONDNFLG ;GET CONDITION FLAG. CHECK IF WE
;ARE DOING A WARMSTART ($00),
;COLDSTART ($80), USING A(RAM)
;($C0) OR DOING A READ ($01).
 BEQ SETIGNOR ;BRANCH IF WARMSTARTING.

* DOING COLDSTART, READING FILE OR USING A(RAM).
* CHECK (A) TO SEE IF USING "?" ASSOCIATED
* WITH READING AN INPUT STATEMENT.

 CMP #"?" ;IF READING, USING "?" AS PROMPT.
 BEQ OPUTHDL6 ;GO DSPLY INPUT CONDITIONALLY IF
;GETTING READY 2 READ A TEXT FILE
;BYTE.
 CMP PROMPT ;ARE WE PRINTING A PROMPT?
 BEQ SET2EVAL ;BRANCH IF ABOUT TO PRINT PROMPT.
SETIGNOR LDX #2 ;SET CONDITION 2 FOR DEFAULT TO
 STX OPUTCOND ;SIGNAL SHOULD IGNORE NON-DOS
;COMMANDS.

 CMP DCTRLCHR ;IS CHAR = DOS'S CTRL CHAR?
 BNE OPUTHDL2 ;NO.
 DEX ;LINE STARTED WITH DOS'S CTRL CHR
 STX OPUTCOND ;SO SET CONDITION 1.
 DEX  ;(X) = 1 --> 0.
 STX NDX2INBF ;INDEX TO 1RST POS'N IN INPUT BUF


*=================================
*        OUTPUT HANDLER 1.
* - COLLECT THE DOS COMMAND.
*   (IE. - STICK CHAR IN THE INPUT
*   BUF & THEN GO DISPLAY CHAR OR
*   ELSE GO PARSE CMD.)
*=================================

OPUTHDL1 LDX NDX2INBF ;GET INDEX TO INPUT BUFFER.
PUTINBUF STA BUF200,X ;PUT CHAR IN INPUT BUFFER.
 INX  ;KICK UP INDEX 4 NEXT BUF POS'N.
 STX NDX2INBF
 CMP #$8D ;WAS CHAR A <CR>?
 BNE DSPLYCMD ;NO.
 JMP PARSECMD ;YES - GOT END OF INPUT, SO NOW
;      SEE IF IT IS A DOS CMD.

