

*======================================
*  THE MON AND NOMON COMMAND HANDLERS.
*======================================

* NOTE:  THE MON & NOMON COMMANDS AND
* THEIR ALPHABETIC ARGUMENTS (C,I,O)
* ARE FIRST DETECTED VIA COMMAND
* PARSING.  CIOCUMUL IS TESTED AT THE
* DSPLYCHR ($9F9F) PORTION OF THE VIDEO
* PARSING ROUTINE TO SEE IF A CHAR
* SHOULD BE SENT TO THE SCREEN OR
* NOT.  IT IS EASY TO BECOME CONFUSED
* OVER THE DISTINCTION BETWEEN
* CIOCUMUL AND MONPRSD.  THE FORMER
* REPRESENTS THE CUMMULATIVE UPDATED
* RECORD OF THE C, I, O ARGUMENTS
* WHEREAS THE LATER DESCRIBES THE
* MOST RECENT ADDITIONS OF THE
* C, I, O ARGUMENTS PRESENT IN THE
* TABLE OF PARSED VALUES.
* THE ALPHABETIC ARUMENTS (C, I, O)
* ARE REPRESENTED BY THE FOLLOWING
* SPECIFIC BITS:
*                C = $40 = %01000000
*                I = $20 = %00100000
*                O = $10 = %00010000
* COMBINATION OF ARGUMENTS ARE SIMPLY
* DESCRIBED BY THE APPROPRIATE BIT
* SETTINGS: EX. CIO = $70 = $01110000

CMDMON LDA CIOCUMUL ;GET PREV CUMMULATIVE RECORD AND
 ORA MONPRSD ;MERGE WITH THE LATEST PARSED VAL
 STA CIOCUMUL ;TO UPDATE CUMMULATIVE RECORD.
 RTS ;RTN 2 THE CALLER OF THE MON CMD.
;(OFTEN RETURNS 2 AFTRCMD ($A17D)
;ASSOCIATED WITH THE COMMAND
;PARSING & PROCESSING ROUTINES.)

CMDNOMON BIT MONPRSD ;TEST BIT6 IN PARSED TBL TO SEE IF
;"NOMON C" IS SELECTED.
 BVC CLRMON ;BRANCH IF "C" NOT INCLUDED.
 JSR CRVIADOS ;"C" WAS INCLUDED, SO PRT <CR>
;CAUSE CMD (BUT NOT <CR>) WAS
;ALREADY PRINTED.

CLRMON LDA #%01110000 ;SHUT OFF BITS IN PARSED TABLE
 EOR MONPRSD ;THAT CORRESPOND 2 THE ALPHABETIC
;ARGUMENTS ISSUED WITH NOMON CMD.
 AND CIOCUMUL ;NOW MAKE SURE THAT THOSE BITS
 STA CIOCUMUL ;ARE OFF IN CUMMULATIVE RECORD.
 RTS ;RTN TO CALLER OF THE NOMON CMD.
;(OFTEN RETURNS 2 AFTRCMD ($A17D)
;ASSOCIATED WITH THE COMMAND
;PARSING & PROCESSING ROUTINES.)


*==================================
*   THE MAXFILES COMMAND HANDLER.
*==================================

* THE MAXFILES COMMAND IS USED TO
* DEFINE THE # OF FILES THAT MAY
* BE OPENED AT ONE TIME (IE. 1-16).
* A DEFAULT VALUE OF 3 IS USED FOR
* COLDSTARTS (IE, WHEN THE DISK IS
* BOOTED) OR WHEN THE FP OR INT
* COMMANDS ARE ISSUED.  THIS VALUE
* CAN BE CHANGED BY ALTERING THE
* CONTENTS OF $AAB1. (THE MAXFILES
* CMD CAN BE TRICKED INTO BUILDING
* ITS BUFFERS AT A LOWER LOCATION
* IN ORDER TO CREATE A SANCTUARY
* WHERE CUSTOM MACHINE LANGUAGE
* ROUTINES CAN'T BE OVERWRITTEN BY
* BASIC.  SEE FORMATTED DIS'MBLY
* OF MAXFILES CMD FOR DETAILS.)

CMDMXFIL LDA #0 ;SHUT OFF THE EXEC FLG.
 STA EXECFLAG
 LDA A5L ;GET ARGUMENT ISSUED WITH CMD AND
 PHA  ;SAVE IT ON THE STK.
;NOTE:  ARGUMENT WAS PREVIOUSLY
;SCREENED TO INSURE THAT IS IS
;BTWN 1 AND 16 ($A0AA - $A0C7).
 JSR CLOSEALL ;CLOSE ALL OPEN FILES.
 PLA ;RETRIEVE ARGUEMENT ISSUED WITH
 STA MXFILVAL ;CMD & STORE IT IN THE MAIN
;VARIABLES TABLE.
 JMP BILDBUFS ;GO BUILD MXFILVAL # OF DOS BUFS.
;RTNS 2 CALLER OF MAXFILES CMD.
;(OFTEN RETURNS 2 AFTRCMD ($A17D)
;ASSOCIATED WITH THE COMMAND
;PARSING & PROCESSING ROUTINES.)


*=================================
*   THE DELETE COMMAND HANDLER.
*=================================

CMDELETE LDA #5 ;OPCODE FOR DELETE.
 JSR HNDLCMD1 ;CLOSE THE FILE & RLEASE ITS BUF.
;REASSIGN A DOS BUF TO THE FILE.
;CHNG FILE DESCRP IN DIR SEC BUF.
;WRITE UPDATED DIR SEC BUF 2 DSK.
;FREE UP DATA & T/S LIST SECTORS.
;WRITE UPDATED VTOC TO DISK.
 JSR GETBUFF ;FIND REASSIGNED DOS BUF.
 LDY #0 ;FREE UP DOS BUF OF FILE BY
 TYA ;STORING A $00 IN 1RST BYTE OF
 STA (A3L),Y ;THE DOS FILE NAME BUFFER.
 RTS ;EXIT 2 CALLER OF THE DELETE CMD.
;(OFTEN RETURNS 2 AFTRCMD ($A17D)
;ASSOCIATED WITH THE COMMAND
;PARSING & PROCESSING ROUTINES.)


*==================================
* THE LOCK AND UNLOCK CMD HANDLERS.
*==================================

CMDLOCK LDA #7 ;LOCK OPCODE.
 BNE LOKUNLOK ;ALWAYS.
CMDUNLOK LDA #8 ;UNLOCK OPCODE.


*---------------------------------
* ROUTINE COMMON TO LOCK, UNLOCK
* AND VERIFY COMMAND HANDLERS.
*---------------------------------

LOKUNLOK JSR HNDLCMD1 ;CALL PART OF THE MAIN COMMAND
;HANDLER ROUTINE TO LOCK, UNLOCK
;OR VERIFY THE FILE.
 JMP CMDCLOSE ;EXIT COMMAND VIA CLOSE.
;RTN 2 THE CALLER OF THE COMMAND.
;(OFTEN RETURNS 2 AFTRCMD ($A17D)
;ASSOCIATED WITH THE COMMAND
;PARSING & PROCESSING ROUTINES.)


*=================================
*   THE VERIFY COMMAND HANDLER.
*=================================

CMDVERFY LDA #12 ;VERIFY OPCODE.
 BNE LOKUNLOK ;GO CALL THE CMD HNDLR TO VERIFY
;FILE & THEN EXIT VIA CLOSE CMD.


*=================================
*   THE RENAME COMMAND HANDLER.
*=================================

CMDRENAM LDA ADRSFNBF ;COPY ADR OF SECONDARY FILENAME 2
 STA RENAMBUF ;RENAME BUF IN FM PARAMETER LIST.
 LDA ADRSFNBF+1
 STA RENAMBUF+1
 LDA #9 ;RENAME OPCODE.
 STA TEMPBYT
 JSR CLOSIFOP ;CLOSE FILE IF IT IS ALREADY OPEN
;AND THEN DO THE RENAME FUNCTION:
; -COPY NEW FILE NAME 2 DIRECTORY
;  SECTOR BUFFER & THEN WRITE THE
;  UPDATED DIREC SEC BACK 2 DISK.
 JMP CMDCLOSE ;EXIT RENAME CMD VIA CLOSE CMD.
;(OFTEN RETURNS 2 AFTRCMD ($A17D)
;ASSOCIATED WITH THE COMMAND
;PARSING & PROCESSING ROUTINES.)


*=================================
*   THE APPEND COMMAND HANDLER.
*=================================

CMDAPPND JSR CMDOPEN ;GO OPEN THE FILE TO BE APPENDED.
READ2END JSR RDTXTBYT ;GO READ A TEXT FILE BYTE.  (USE
;THE READ FUNCTION AND READ-ONE-
;BYTE SUBFUNCTION.)
 BNE READ2END ;TAKE BRANCH IF DEALING WITH A
;VALID (IE. NON-ZERO) DATA BYTE.
;HAVEN'T ENCOUNTERED AN END-OF-
;FILE MARKER ($00) YET,SO GO BACK
;TO READ THE REST OF THE FILE.
 JMP CKAPFLG ;FOUND END OF FILE,SO NOW GO BACK
;UP THE FILE POINTER IF NECESSARY
;AND EVENTUALLY EXIT THE APPEND
;CMD HANDLER VIA RSETPTRS ($B6B3)
;AND FMEXIT ($B386).  NOTE THAT
;RSETPTRS RESETS THE SAVED STACK
;POINTER (STKSAV, $B39B) SO WE
;EVENTUALLY RETURN TO THE CALLER
;OF THE APPEND COMMAND. EXECUTION
;OFTEN RETURNS TO AFTRCMD ($A17D)
;LOCATED IN THE COMMAND PARSING
;AND PROCESSING ROUTINES.


*=================================
*    THE OPEN COMMAND HANDLER.
*=================================

CMDOPEN LDA #0 ;CODE FOR TEXT FILE.
 JMP OPNCKTYP ;GO OPEN THE FILE & CHK ITS TYPE.
;RTN 2 THE CALLER OF THE OPEN CMD
;(OFTEN RETURNS 2 AFTRCMD ($A17D)
;ASSOCIATED WITH THE COMMAND
;PARSING & PROCESSING ROUTINES.)


*====================================
* COMMON FILE MANAGER CMD HNDLR CODE.
*====================================

HNDLCMD LDA #1 ;OPEN OPCODE.
HNDLCMD1 STA TEMPBYT ;STORE OPCODE IN TEMPBYT.
 LDA LENPRSD ;GET L-PARAMETER FROM PARSED TBL.
 BNE SAVLENFM ;CHECK IF A NON-ZERO L-PARM WAS
;ISSUED WITH THE COMMAND.
 LDA LENPRSD+1
 BNE SAVLENFM
 LDA #1 ;LNGTH WAS 0 SO MAKE IT 1 INSTEAD
 STA LENPRSD
SAVLENFM LDA LENPRSD ;PUT LENGTH IN FM PARAMETER LIST.
 STA RECLENFM ;NOTE:  RECORD LENGTH = 1 FOR
 LDA LENPRSD+1 ;SEQUENTIAL FILES, ELSE PARSED
 STA RECLENFM+1 ;LENGTH FOR RANDOM ACCESS FILES.


*----------------------------------
* CLOSE FILE IF IT IS ALREADY OPEN.
*----------------------------------

CLOSIFOP JSR CMDCLOSE ;CLOSE IF ALREADY OPEN.
 LDA A5L+1 ;A5L/H POINTS AT HIGHEST NUMBERED
;(LOWEST IN MEMORY) FREE DOS BUF.
 BNE SAVFNPTR ;BRANCH IF FOUND A FREE BUFFER.
 JMP NOBUFERR ;COULDN'T LOCATE A FREE BUFFER SO
;GO ISSUE OUT OF BUF'S MSG.
SAVFNPTR STA A3L+1 ;RESET A3L/H TO POINT AT DOS BUF
 LDA A5L ;THAT WILL USE 4 FILENAME FIELD.
 STA A3L
 JSR CPYPFN ;REASSIGN A DOS BUFFER 2 THE FILE
;WE WANT TO OPEN.
 JSR BUFS2PRM ;GET ADDR'S OF THE VARIOUS DOS
;BUFFERS FROM THE CHAIN BUFFER &
;PUT THEM IN THE FM PARM LIST.
 JSR CPY2PARM ;PUT VOL, DRV, SLOT & ADDR OF THE
;PRIMARY FILENAME BUFFER IN THE
;FM PARAMETER LIST.
 LDA TEMPBYT ;GET OPCODE BACK FROM TEMPBYT AND
 STA OPCODEFM ;STICK IT IN THE FM PARM LIST.
 JMP FMDRIVER ;USE FILE MANAGER TO DO FUNCTION.


*=================================
*    THE CLOSE COMMAND HANDLER.
*=================================

CMDCLOSE LDA PRIMFNBF ;GET 1RST CHR FRM PRMRY NAME BUF.
 CMP #" " ;DON'T ALLOW LEADING SPACES.
 BEQ CLOSEALL ;LEADING SPC = SIGNAL 2 CLOSE ALL
;FILES.  (A CLOSE CMD WAS ISSUED
;WITH NO ACCOMPANYING FILE NAME.)
 JSR GETBUFF ;LOCATE A DOS BUFFER WITH SAME
;NAME, ELSE LOCATE A FREE BUFFER.

EVENTXIT BCS CLOSERTS ;EVENTUALLY EXIT VIA THIS ROUTE!!

 JSR CLOSEONE ;MATCHING FILENAME WAS FOUND SO
;GO CLOSE THAT FILE.
 JMP CMDCLOSE ;GO BACK TO POINT A5L/H AT A FREE
;DOS BUFFER & EXIT VIA EVENTXIT
;($A2F4) AND CLOSERTS ($A330).


*---------------------------------
*      CLOSE A SPECIFIC FILE
*      (& FREE ITS BUFFER).
*---------------------------------

CLOSEONE JSR CKEXCBUF ;CHK IF CURRENT FILENAME BUFFER
;BELONGS TO AN EXEC FILE.
 BNE FREEBUFF ;BRANCH IF NOT EXECING FROM THIS
;PARTICULAR FILE.  NOTE, ALWAYS
;TAKE BRANCH IF CLOSEONE ($A2FC)
;IS ACCESSED VIA CLOSEALL ($A316)
 LDA #0 ;CLOSING AN EXEC FILE SO SHUT OFF
 STA EXECFLAG ;THE EXEC FLAG. NOTE:THIS INSTRUC
;IS NEVER CARRIED OUT IF ACCESSED
;VIA CLOSEALL.  (AN ACTIVE EXEC
;FILE WAS ALREADY DETECTED AND
;SKIPPED BY THE "BEQ CHKNXBUF"
;INSTRUCTION AT $A323.)
FREEBUFF LDY #0 ;FREE UP DOS BUF BY POKING A $00
 TYA ;IN 1RST BYT OF DOS FILENAME BUF.
 STA (A3L),Y
 JSR BUFS2PRM ;GET ADDR'S OF THE VARIOUS DOS
;BUFS FROM THE CHAIN BUF & PUT
;THEM IN THE FM PARAMETER LIST.
 LDA #2 ;PUT OPCODE FOR CLOSE FUNCTION
 STA OPCODEFM ;IN THE FM PARAMETER LIST.
 JMP FMDRIVER ;GO TO THE FILE MANAGER DRIVER TO
;DO THE CLOSE FUNCTION.


*---------------------------------------
* CLOSE ALL FILES (EXCEPT AN EXEC FILE).
* ENTER CLOSEALL WHEN IT IS ACCESSED VIA
* A DIRECT CALL OR IF THE FIRST CHAR IN
* THE PRIMAY FILENAME FIELD WAS A SPACE.
*---------------------------------------

CLOSEALL JSR GETFNBF1 ;PUT ADR OF 1RST DOS FILENAME BUF
;(LOCATED IN CHAIN OF DOS BUFS)
;IN THE A3L/H POINTER.
 BNE CKIFEXEC ;ALWAYS.
CHKNXBUF JSR GETNXBUF ;GET ADR OF NEXT DOS FILENAME BUF
;FROM DOS CHAIN POINTERS BUFFER
;(OFFSET 37 & 36 BYTES FROM 1RST
;CHR OF PRESENT DOS FILENAME BUF)
 BEQ CLOSERTS ;LNK ZEROED OUT -ALL FILES CLOSED
;(EXIT CLOSEALL VIA THIS ROUTE.)
CKIFEXEC JSR CKEXCBUF ;CHK IF CURRENT DOS FILENAME BUF
;BELONGS TO TO AN EXEC FILE.
 BEQ CHKNXBUF ;EXEC ACTIVE SO DON'T CLOSE ITS
;BUFFER OUT OR WILL END UP
;IN NEVER-NEVER LAND.  AFTER ALL,
;DON'T WANT TO CLOSE BUFFER IF WE
;ARE USING IT 2 EXEC (IE. WOULD
;BE LIKE BURYING SELVES ALIVE)!!
 JSR GETFNBY1 ;GET 1RST BYTE IN DOS NAME BUF.
 BEQ CHKNXBUF ;THIS FILE IS ALREADY CLOSED SO
;GO BACK TO CLOSE REST OF FILES.
 JSR CLOSEONE ;FILE WAS OPEN SO GO CLOSE IT.
 JMP CLOSEALL ;GO TO CLOSERTS VIA CLOSEALL!!!
CLOSERTS RTS ;EXIT TO CALLER OF THE CLOSE CMD.
;(OFTEN EXITS TO AFTRCMD ($A17D)
;LOCATED IN THE COMMAND PARSING &
;PROCESSING ROUTINES.)


*=================================
*    THE BSAVE COMMAND HANDLER.
*=================================

CMDBSAVE LDA #%00001001 ;TEST BITS0 & 3 OF CUMLOPTN 2 SEE
 AND CUMLOPTN ;IF A(DDR) & L(ENGTH) PARAMETERS
 CMP #%00001001 ;WERE ISSUED WITH THE BSAVE CMD.
 BEQ DOBSAV ;BOTH A- & L-PARMS PRESENT.
 JMP CKIFCTRL ;GOT A SYNTAX ERROR.

DOBSAV LDA #4 ;CODE FOR BINARY FILE.
 JSR OPNCKTYP ;CLOSE (IF NECESSARY) & THEN OPN.
 LDA ADRPRSD+1 ;PREPARE TO WRITE ADDR TO DISK.
 LDY ADRPRSD
 JSR WRADRLEN ;CALL WRITE-ONE-BYTE SUBFUNCTION
;TWICE TO PUT A(DDR)-PARAMETER IN
;DATA SEC BUF. (NOTE: LEN2RDWR IS
;USED AS A TEMPORAY BUFFER FOR
;FOR DATA TRANSFER.)

 LDA LENPRSD+1 ;PREPARE TO WRITE FILE LENGTH.
 LDY LENPRSD
 JSR WRADRLEN ;CALL WRITE-ONE-BYTE SUFUNCTION 2
;WRITE LENGTH AS THE 3RD & 4TH
;BYTES IN THE DATA SEC BUF.
;(LATER BUF WRITTEN AS 1RST SEC
;OF FILE.  LEN2RDWR IS AGAIN USED
;AS A TEMP BUF 4 DATA TRANSFER.)

* NOW PREPARE TO WRITE THE REST
* OF THE BINARY FILE TO THE DISK.

 LDA ADRPRSD+1 ;PUT ADDR OF SOURCE BUFFER IN
 LDY ADRPRSD ;THE FM PARAMETER LIST.
 JMP RDWRANGE ;GO TO WRITE-RANGE ROUTINE TO
;WRITE REST OF FILE TO THE DISK.
;(FILE IS ALSO VERIFIED AND THEN
;EXITED VIA THE CLOSE COMMAND.)
;EXECUTION EVENTUALLY RETURNS TO
;THE CALLER OF THE BSAVE COMMAND.
;OFTEN, RETURNS 2 AFTRCMD ($A17D)
;LOCATED IN THE CMD PARSING AND
;PROCESSING ROUTINES.


*=================================
*      BLOAD COMMAND HANDLER
*=================================

CMDBLOAD JSR HNDLCMD ;CALL THE FM COMMAND HANDLER TO
;OPEN THE FILE.

* COMPARE FILE TYPE WANTED
* WITH FILE TYPE FOUND.

 LDA #$7F ;STRIP LOCK BIT FROM FILE TYPE
 AND FILTYPFM ;FOUND (VIA OPEN FUNCTION).
 CMP #4 ;WAS FILE FOUND A BINARY FILE?
 BEQ ADR4BLOD ;YES.
 JMP TYPMISM ;NO - GO ISSUE FILE-MISMATCH MSG.

* REDUNDANT CODE!  CLOSE (IF NECESSARY)
* AND THEN OPEN THE FILE AGAIN.

ADR4BLOD LDA #4 ;CODE FOR BINARY FILE.
 JSR OPNCKTYP ;CLOSE & REOPEN FILE.
 JSR RDADRLEN ;READ THE BLOAD ADR FROM THE DISK
;INTO LEN2RDWR.
 TAX ;X=LOW BYTE OF BLOAD ADR FRM DSK
 LDA CUMLOPTN ;CHK CUMLOPTN TO SEE IF AN A(DDR)
 AND #%00000001 ;WAS ISSUED WITH THE BLOAD CMD.
 BNE LEN4BLOD ;YES -SO IGNORE ADR READ FROM DSK
;      & USE THE ACTUAL PARSED
;      A-PARAMETER INSTEAD.
 STX ADRPRSD ;STORE ADR READ FRM DSK IN PARSED
 STY ADRPRSD+1 ;TABLE.  (THIS WAY CAN ALWAYS USE
;VAL IN TABLE FOR BLOAD ADR.)

LEN4BLOD JSR RDADRLEN ;READ THE BLOAD LENGTH OFF DSK.
;(PUT RESULTS IN LEN2RDWR.)
 LDX ADRPRSD ;SET (X)/(Y) = EITHER ORIG PARSED
 LDY ADRPRSD+1 ;A-PARM ADR OR BLOAD ADR FRM DSK.
 JMP LODINTFP ;GO READ THE REST OF THE FILE IN.
;EXITS VIA THE CLOSE COMMAND.
;RETURNS TO CALLER OF THE BLOAD
;CMD. (IF BLOAD CMD NOT CALLED BY
;BRUN, THEN OFTEN RTNS TO AFTRCMD
;($A17D) LOCATED IN THE COMMAND
;PARSING & PROCESSING ROUTINES.)


*=================================
*       BRUN COMMAND HANDLER
*=================================

CMDBRUN JSR CMDBLOAD ;BLOAD THE PRGM.
 JSR INITIOHK ;POINT THE I/O HOOKS AT DOS.
;NOTE:  THIS CAN CREATE SOME
;EXOTIC BUGS IF THE BRUNED PRGM
;PRINTS ANY INFO OR IF "MON" IS
;ACTIVE.  SEE FORMATTED DIS'MBLY
;OF BRUN CMD FOR EXPLANATION.)
 JMP (ADRPRSD) ;BEGIN EXECUTION OF BINARY PRGM.
;EXECUTION NORMALLY RETURNS TO
;AFTRCMD ($A17D) LOCATED IN THE
;CMD PARSING AND PROCESSING
;ROUTINES.  ALSO NOTE THAT
;THE COMPUTER MAY HANG ON CERTAIN
;OCCASSIONS.  (SEE THE FORMATTED
;DISASSEMBLY OF THE BRUN CMD FOR
;EXPLANATION.)


*=================================
*      SAVE COMMAND HANDLER
*=================================

CMDSAVE LDA ACTBSFLG ;CHK WHICH BASIC IS ACTIVE.
 BEQ SAVINTGR ;BRANCH IF USING INTEGER.
;INT=$00, A(ROM)=$40, A(RAM)=$80.
 LDA PROTFLG ;IF PROTECTION FLAG IS ON (IE. IS
;NEGATIVE), THEN ALL APPLESOFT
;CMDS CAUSE RUN & DOS'S SAVE CMD
;CAUSES A PHONY PROGRAM-TOO-LARGE
;MESSAGE TO BE GENERATED.
 BPL SAVAPSFT ;BRANCH IF PROTECTION FLG IS OFF.
 JMP TOOLARGE ;PROTECTED!!! - SPIT OUT PHONY
;PROGRAM-TOO-LARGE MESSAGE & XIT.


*---------------------------------
*      SAVE AN APPLESOFT FILE
*---------------------------------

SAVAPSFT LDA #2 ;CODE FOR APPLESOFT FILE.
 JSR OPNCKTYP ;GO OPEN THE NAMED FILE & CHECK
;ITS TYPE.
 SEC ;CALC THE LNGTH OF THE PRGM SO WE
 LDA PRGEND ;CAN WRITE IT AS 1RST TWO BYTES:
 SBC TXTTAB ;        LENGTH = PRGEND - TXTTAB
 TAY
 LDA PRGEND+1
 SBC TXTTAB+1

 JSR WRADRLEN ;WRITE THE LENGTH OF THE FP FILE
;BY USING THE WRITE-ONE-BYTE
;SUBFUNCTION TWICE.

* PREPARE TO WRITE REST OF FILE.

 LDA TXTTAB+1 ;PRGM START = START OF OUTPUT BUF
 LDY TXTTAB
 JMP RDWRANGE ;GO TO THE WRITE-RANGE-OF-BYTES
;ROUTINE 2 WRITE THE REST OF FILE
;AND THEN VERIFY IT.
;AFTER VERIFICATION, THE SAVE CMD
;IS EXITED VIA THE CLOSE CMD.
;EXECUTION THEN RETURNS TO CALLER
;OF THE SAVE CMD.  (OFTEN RTNS TO
;AFTRCMD ($A17D) LOCATED IN THE
;DOS CMD PARSING AND PROCESSING
;ROUTINES.)


*---------------------------------
*      SAVE AN INTEGER FILE
*---------------------------------

SAVINTGR LDA #1 ;CODE FOR INTEGER FILE.
 JSR OPNCKTYP ;GO OPEN THE INTEGER FILE.

 SEC ;CALC LENGTH OF FILE.
 LDA HIMEM
 SBC INTPGMST
 TAY
 LDA HIMEM+1
 SBC INTPGMST+1

 JSR WRADRLEN ;WRITE LNGTH 2 DSK BY CALLING THE
;WRITE-ONE-BYTE SUBFUNCTION TWICE
 LDA INTPGMST+1
 LDY INTPGMST
 JMP RDWRANGE ;WRITE THE REST OF FILE TO DSK.


*=================================
* OPEN NAMED FILE & CHECK ITS TYPE
*=================================

OPNCKTYP STA FILTYPFM ;PUT CODE FOR FILE TYPE IN THE
 PHA ;FM PARAMETER LIST & SAVE ON STK.
;($00=TXT, $01=INT, $02=FP,
;$04=BIN, $08=S-TYPE, $10=RELOC,
;$20=A-TYPE AND $40=B-TYPE.)
 JSR HNDLCMD ;USE THE FM CMD HANDLER TO OPEN.
 PLA ;PULL THE FILE TYPE CODE FRM STK.
 JMP CHKFTYPE ;GO CHK IF TYPE WNTD = TYPE FOUND


*============================================
*            WRITE TWO BYTES.
*--------------------------------------------
* CODE WHICH WRITES ADDRESS AND LENGTH VALUES
* TO THE DATA SECTOR BUFFER.  (LATER, THE
* DATA SEC BUF IS WRITTEN TO THE DISK.)
* CALLS WRITE-ONE-BYTE SUBFUNCTION TWICE.
* NOTE THAT LEN2RDWR IS USED AS A TEMPORARY
* BUFFER FOR DATA TRANSFER AS SHOWN BELOW:
* - LOW BYTE OF ADR OR LENGTH --> LEN2RDWR
*   --> ONEIOBUF --> DATA SECTOR BUFFER.
* - HI BYTE OF ADR OR LENGTH --> LEN2RDWR+1
*   --> ONEIOBUF --> DATA SECTOR BUFFER.
*============================================

WRADRLEN STY LEN2RDWR ;PUT LOW BYTE IN FM PARM LIST IN
;CASE THIS IS A L-PARM & WE NEED
;IT AS A COUNTER WHEN LATER WRITE
;RANGE OF BYTES TO DISK.
 STY ONEIOBUF ;PUT BYTE TO WRITE IN PARM LIST.
 STA LEN2RDWR+1 ;PUT HI BYTE IN FM PARM LIST IN
;CASE THIS IS A L-PARM & WE NEED
;IT AS COUNTER WHEN LATER WRITE
;RANGE OF BYTES TO DISK.
 LDA #4 ;PUT WRITE OPCODE IN FM PARM LIST
 STA OPCODEFM
 LDA #1 ;PUT ONE-BYTE SUBCODE IN PARM LST
 STA SUBCODFM
 JSR FMDRIVER ;CALL FM DRV TO WRITE 1RST BYTE.
 LDA LEN2RDWR+1 ;PUT HI BYTE TO WRITE IN PARM LST
 STA ONEIOBUF
 JMP FMDRIVER ;GO WRITE HI BYTE TO FILE.


*=================================
*   READ/WRITE A RANGE OF BYTES
*=================================

RDWRANGE STY CURIOBUF ;PUT ADR OF OUTPUT BUF IN PRM LST
 STA CURIOBUF+1
 LDA #2 ;SET SUBCODE FOR RANGE OF BYTES.
 JMP VRFYRWNG ;GO CALL THE FILE MANAGER TO WRITE
;DATA TO THE DISK.  NEXT VERIFY
;THE INFO & CLOSE THE FILE.


*=================================
* CALL FM DRIVER & THEN CLOSE FILE
*=================================

CLOSEFM JSR FMDRIVER ;CALL THE FM DRIVER 2 READ/WRITE.
 JMP CMDCLOSE ;GO CLOSE THE FILE.


*========================================
* GO ISSUE A FILE-TYPE-MISMATCH ERROR MSG
*========================================

TOTYPMIS JMP TYPMISM ;GO HANDLE MISMATCH ERROR.


*=================================
*      LOAD COMMAND HANDLER
*=================================

CMDLOAD JSR CLOSEALL ;CLOSE ALL FILES (EXCEPT ACTIVE
;EXEC FILE).
OPENLOAD JSR HNDLCMD ;GO OPEN THE FILE.

 LDA #%00100011 ;SET BITS IN (A) TO RESTRICT LOAD
;CMD 2 APLSFT ($02), INTGR ($01)
;OR A-TYPE ($20) FILES.
 AND FILTYPFM ;TYPE FOUND (VIA OPEN FUNCTION).
 BEQ TOTYPMIS ;ERR -NOT ONE OF THE ABOVE TYPES.
;GO ISSUE TYPE-MISMATCH ERR MSG.
 STA FILTYPFM ;SAVE TYPE WANTED IN FM PARM LIST

 LDA ACTBSFLG ;CHK WHICH LANG IS ACTIVE:
;    INT=$00, FP=$40, A(RAM)=$80)
 BEQ LODINTGR ;BRANCH IF USING INTEGER.

 LDA #2 ;CODE FOR APPLESOFT (FP).
 JSR SELCTBSC ;CHK IF TYPE WANTED IS APPLESOFT.

 JSR RDADRLEN ;READ LENGTH OF THE FP PRGM FROM
;THE 1RST 2 BYTES OF THE FILE.

* CHK TO SEE IF THERE IS ENOUGH ROOM
* BETWEEN PRGM START POS'N & MEMSIZ
* TO ACCOMODATE FILE.

 CLC ;ADD LNGTH OF FILE 2 START OF PGM
 ADC TXTTAB ;(NORMALLY, $801).
 TAX ;SAVE LOW BYTE OF PRGEND IN (X).
 TYA ;RETRIEVE HI BYTE OF LEN FROM (Y)
 ADC TXTTAB+1

 CMP MEMSIZ+1
 BCS TOTOOLRG ;BRANCH IF NOT ENOUGH ROOM.
;(GO ISSUE PRGM-TOO-LARGE MSG.)

* PRGM IS SHORT ENOUGH TO BE
* ACCOMODATED IN FREE MEMORY SPACE.
*
* SET ZERO-PAGE POINTERS.

 STA PRGEND+1 ;SET END OF PRGM POINTER.
 STA VARTAB+1 ;SET START OF VARIABLE SPACE.
 STX PRGEND ;PRGEND: VAL IN TXTTAB + LENGTH.
 STX VARTAB ;VARTAB: VAL IN TXTTAB + LENGTH.
 LDX TXTTAB
 LDY TXTTAB+1

 JSR LODINTFP ;DESIGNATE WHERE IN FREE MEMORY 2
;LOAD PRGM & THEN GO LOAD IT.
 JSR INITIOHK ;POINT THE I/O HOOKS AT DOS.
 JMP (RLOCNTRY) ;NORMALLY PTS TO SETLINKS ($D4F2)
;ROUTINE IN BASIC WHICH SETS
;IMPORTANT Z-PAGE POINTERS,
;CLEARS OUT VARIABLES, RESETS STK
;PTR & THEN ADJUSTS LINKS IN EACH
;PROGRAM LINE.
;EVENTUALLY, EXECUTION FLOWS INTO
;BSC'S WRMSTART (RESTART, $D43C).
;IF THE LOAD CMD WAS CALLED VIA
;THE RUN CMD, EXECUTION BRANCHES
;BACK 2 THE RUNFPINT ($A4DC) PART
;OF THE RUN CMD (AFTER ADJUSTING
;THE STACK).
;IF LOAD WAS NOT CALLED FROM RUN,
;THEN THE THE RESTART ($D43C)
;PORTION OF BASIC EVENTUALLY
;REQUESTS FURTHER PRGM OR KEYBRD
;INPUT & ANOTHER CMD IS PARSED.


*---------------------------------
*     LOAD AN INTEGER PROGRAM
*---------------------------------

LODINTGR LDA #1 ;CODE 4 INTEGER BASIC FILE TYPE.
 JSR SELCTBSC ;CHK IF INTEGER BASIC IS ACTIVE.
;IF NOT, SWTCH FROM FP 2 INTEGER.
 JSR RDADRLEN ;READ 1RST 2 BYTES OF FILE TO GET
;LENGTH OF PRGM TO LOAD.
 SEC ;CALC START OF PRGRM.
 LDA HIMEM ;(HIMEM - LENADRBF.)
 SBC LENADRBF
 TAX
 LDA HIMEM+1
 SBC LENADRBF+1

 BCC TOTOOLRG ;LENGTH > HIMEM SO ISSUE ERR MSG.
 TAY
 CPY LOMEM+1 ;CHK IF PRGM < = LOMEM.
 BCC TOTOOLRG ;START OF PRGM TOO LOW, SO GO
 BEQ TOTOOLRG ;ISSUE PRGM-TOO-LARGE ERROR MSG.

 STY INTPGMST+1 ;SET START-OF-PRGM POINTER.
 STX INTPGMST

*=================================
*    GO DO THE ACTUAL LOAD.
*    (COMMON LOAD ROUT'N FOR
*    FP OR INTEGER LOAD CMDS.)
*=================================

LODINTFP STX CURIOBUF ;DESIGNATE LOAD ADDR AS I/O BUF
 STY CURIOBUF+1 ;IN THE FM PARAMETER LIST.
 JMP CLOSEFM ;USE FILE MANAGER TO LOAD PRGM.


*=================================
*  COMMON CODE USED TO READ THE
*  BLOAD ADDRESS, BLOAD LENGTH
*  OR LOAD LENGTH FROM THE DISK.
*=================================

RDADRLEN LDA ADLENADR ;GET ADR OF TWO-BYTE INPUT BUFFER
 STA CURIOBUF ;(LENADRBF, $AA60) FRM RELOCATBL
 LDA ADLENADR+1 ;CONSTANTS TBL & DESIGNATE IT AS
 STA CURIOBUF+1 ;THE I/O BUF IN THE FM PARM LIST.
 LDA #0 ;PUT LENGTH TO READ = 2 BYTES IN
 STA LEN2RDWR+1 ;THE FM PARM LIST.
 LDA #2
 STA LEN2RDWR
 LDA #3 ;PUT READ OPCODE IN FM PARM LIST.
 STA OPCODEFM
 LDA #2 ;INDICATE WANT 2 READ RNG OF BYTS
 STA SUBCODFM
 JSR FMDRIVER ;GO READ IN THE ADDR (OR LENGTH).
 LDA LENADRBF+1 ;GET HI BYTE OF ADR (OR LENGTH)
;JUST READ FROM DISK.
 STA LEN2RDWR+1 ;PUT VAL JUST RD IN PARM LIST IN
;CASE JUST READ LENGTH (SO KNOW
;HOW MUCH TO READ WHEN READ MAIN
;BODY OF FILE).
 TAY ;SAVE HI BYTE IN (Y).
 LDA LENADRBF ;DO LIKEWISE WITH LOW BYTE.
 STA LEN2RDWR
 RTS


*=================================
* CLOSE FILE & ISSUE A PROGRAM-
* TOO-LARGE ERROR MESSAGE.
*=================================

TOTOOLRG JSR CMDCLOSE ;CLOSE FILE.
 JMP TOOLARGE ;ISSUE ERROR MSG.


*=================================
*     SELECT DESIRED BASIC
*=================================

* CHK IF DESIRED BASIC IS UP OR NOT
* (SWITCH BASIC IF NECESSARY).

SELCTBSC CMP FILTYPFM ;TYPE WANTED = TYPE FOUND?
 BEQ SELBSRTN ;YES - BASIC WANTED IS ACTIVE.

 LDX NDX2CMD ;SAVE INDEX 2 PRESENT CMD IN CASE
 STX NEXTCMD ;WE ARE USING INTEGER & MUST LOAD
;INTEGER FILE CALLED "APPLESOFT"
;IN ORDER TO LOAD A(RAM).
 LSR ;SHIFT TYPE WANTED TO SEE WHICH
;BASIC TO SWITCH INTO.
 BEQ SWTCH2FP ;SWITCH FROM INTEGER 2 APPLESOFT.
 JMP CMDINT ;SWITCH FROM APPLESOFT 2 INTEGER.


* SWITCHING FROM INT TO APPLESOFT
* SO COPY NAME OF FILE FROM PRIMARY
* TO SECONDARY NAME BUF IN CASE WE
* HAVE TO USE RAM-BASED APPLESOFT.

SWTCH2FP LDX #29 ;30 BYTES TO COPY (0 TO 29).
PRIM2SND LDA PRIMFNBF,X ;GET BYTE FROM PRIMARY.
 STA SCNDFNBF,X ;COPY IT TO SECONDARY.
 DEX
 BPL PRIM2SND ;BRANCH IF MORE BYTES TO COPY.

 JMP CMDFP ;EXECUTE THE FP COMMAND.

SELBSRTN RTS ;DESIRED BASIC WAS ACTIVE.


*=================================
*       RUN COMMAND HANDLER
*=================================

CMDRUN LDA ACTBSFLG ;CHK WHICH BASIC IS CURRENT.
 BEQ LOAD4RUN ;BRANCH IF USING INTEGER BASIC.

 STA RUNTRUPT ;SET THE RUN INTERCEPT FLAG TO
;SIGNAL THAT WE ARE ABOUT TO
;INTERRUPT THE RUN COMMAND TO DO
;LOAD.  ($40=A(ROM), $80=A(RAM).)
LOAD4RUN JSR CMDLOAD ;GO LOAD THE PROGRAM.
;************* NOTE *************
;* THE "JSR" IS ACTUALLY A      *
;* PLACEBO BECAUSE AFTER FILE   *
;* IS LOADED, EXECUTION GOES IN2*
;* BASIC & THEN RE-ENTERS DOS   *
;* THRU THE DOS INTERCEPTS. ONCE*
;* DOS GETS ITS MITTS BACK INTO *
;* THINGS, THE RUNTRUPT FLAG IS *
;* TESTED & THEN EXECUTION FLOWS*
;* TO THE NEXT INSTRUCTION (AT  *
;* RUNFPINT).  THE MACHINE DOES *
;* NOT GET LOST BECAUSE THE STK *
;* PTR GETS RESET ACCORDINDLY.  *
;********************************

RUNFPINT JSR CRVIADOS ;PRINT A <CR>.
 JSR INITIOHK ;RESET THE I/O HKS TO PT TO DOS.
 JMP (RUNTRY) ;GO EXECUTE THE PRGM.
;(RUNTRY PTS TO RUNFPROM IF USING
;A(ROM) OR POINTS TO FPRAMRUN
;IF USING A(RAM).)


*=======================================
* INTEGER BASIC'S RUN CMD ENTRY POINT.
* (RUNTRY PTS HERE WHEN INTEGER ACTIVE.)
*=======================================

RUNINTGR LDA LOMEM ;CLEAR OUT ALL VARIABLES.
 STA INTVRLND ;ZERO OUT INTEGER BASIC'S CURRENT
 LDA LOMEM+1 ;VARIABLE POINTER.
 STA INTVRLND+1
 JMP (CHAINTRY) ;GO INTO INTEGER BASIC 2 EXECUTE.


*=================================
*      CHAIN COMMAND HANDLER
*=================================

CMDCHAIN JSR OPENLOAD ;LOAD THE INTEGER PRGM.
 JSR CRVIADOS ;PRINT A <CR>.
 JSR INITIOHK ;POINT I/O HOOKS AT DOS.
 JMP (CHAINTRY) ;GO INTO INTEGER BASIC 2 EXECUTE.


*=================================
*    A(ROM)'S RUN ENTRY POINT.
*  (RUNTRY POINTS HERE IF A(ROM)
*  BASIC IS ACTIVE.)
*=================================

RUNFPROM JSR SETZPTRS ;CLEAR OUT ALL VARIABLES.
 STA PROMPT ;ZERO OUT PROMPT & ON-ERROR FLAG.
 STA ERRFLG
 JMP NEWSTT ;JUMP INTO BASIC TO EXECUTE PRGM.


*=================================
*    A(RAM)'S RUN ENTRY POINT.
*  (RUNTRY POINTS HERE IF A(RAM)
*  VERSION OF BASIC IS UP.)
*=================================

FPRAMRUN JSR CLRFPRAM ;CLEAR ALL VARIABLES.
 STA PROMPT ;ZERO OUT PROMPT & ON ERROR FLAG.
 STA ERRFLG
 JMP RUNFPRAM ;GO RUN THE PROGRAM.
 #
