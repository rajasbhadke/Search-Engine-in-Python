**********************************
*                                *
* ADDRS USED IN THE FORMATTED    *
* DIS'MBLIES BUT NOT REFERENCED  *
* IN THE LINEAR DIS'MBLIES.      *
* (THESE ADRS ARE INCLUDED TO    *
* MAKE THE SYMBOL TBLS APPLICABLE*
* TO BOTH DIS'MBLIES.)           *
*                                *
**********************************



*--------------------------------*
*       ZERO-PAGE LOCATIONS      *
*--------------------------------*

LOC0 = $00 ;REFERENCE ADR USD BY MONITOR ROM
;ROUTINES THAT SIMULATE IN# & PR#
;STATEMENTS.
LOC1 = $01 ;AS ABOVE.
GOWARM = LOC0 ;A JMP INSTRUC (3 BYTES, $00-$02)
;TO BASIC'S WARMSTART (RESTART,
;$D43C) ROUTINE.  HOWEVER, WHEN
;COLDSTARTING, IS TEMPORARILY SET
;TO JUMP INTO BASIC'S COLDSTART
;AT BSCOLDST ($F128).
GOSTROUT = $03 ;A JMP INSTRUC (3 BYTES, $03-$05)
;TO THE BASIC ROUTINE THAT PRINTS
;THE STRING IN MEMORY POINTED TO
;BY (A) & (Y) REGS (IN LOW/HI
;FORMAT).  HOWEVER, WHEN COLD-
;STARTING, IS TEMPORARILY SET TO
;JMP IN2 BASIC'S COLSTART ROUTINE
;AT BSCOLDST ($F128).
USR = $0A ;JUMP INSTRUC (3 BYTES, $0A-$0C)
;TO USR ROUTINE.  HOWEVER, WHEN
;COLDSTARTING, IS TEMPORARILY
;PTING AT ILLEGAL-QUANTITY ROUT'N
SUBFLG = $14 ;SUBSCRIPT FLAG:
;$00 = SUBSCRIPT ALLOWED.
;$80 = NO SUBSCRIPTS.
WNDWDTH = $21 ;WIDTH OF TEXT SCREEN WINDOW.
INVFLG = $32 ;INVERSE FLAG MASK: NORMAL = $FF,
;INVERSE = $3F & FLASHING = $7F.
;HACKER'S OFTEN ZAP THIS BYTE TO
;FILTER OUTPUT AS PART OF A
;PROTECTION SCHEME (INVIS = $80).
BT0SCRTH = $3C ;MAIN SCRATCH REG USED BY BOOT0.
A2L = $3E ;MULTIPURPOSE REG & PTR ($3E,$3F)
BOOTEMP = $40 ;TRK # READ OFF DSK WHEN BOOTING.
BOOTRK = $41 ;TRK # WANTED WHEN READING IN DOS
;DURING THE BOOT PROCESS.
TEMPPT = $52 ;PREVIOUS TEMP STRING DESCRIPTOR.
LASTPT = $53 ;PREVIOUS TEMP STRING POINTER.
TEMPST = $55 ;PREVIOUS STRING POINTER USED IN
;GARBAGE COLLECTION ROUTINES.
INDEX = $5E ;TEMP STK PTR FOR MOVING STRINGS.
ARYTAB = $6B ;PTR ($6B,$6C) TO START OF THE
;ARRAY VARIABLES.
STREND = $6D ;PTR ($6D,$6E) TO START OF FREE
;SPACE. (1 BYTE BEYOND THE END OF
;THE ARRAY VARIABLES.)
OLDTEXT = $79 ;PTR ($79,$7A) TO NEXT STATEMENT
;TO BE EXECUTED.
DATPTR = $7D ;PTR ($7D,$7E) TO NEXT BYTE TO BE
;USED FOR A DATA STATEMENT.
DSCLEN = $8F ;TEMP BYTE USD 4 GARBAGE COLLECT.
JMPADRS = $90 ;JMP INTRUC ($90-$92) TO VARIABLE
;ADDR.
TEMPRY = $A4 ;TEMP BYTE USED IN FLOATING POINT
;MATH ROUTINES.
CHRGET = $B1 ;GET BYTE OF TEXT FROM TXTPTR IN
;(A), INCREMENT TXTPTR AND EXIT
;WITH: (A) = ORIGINAL CHAR.
;      (Z) = 0 IF (A) = ":" OR $00
;          = 1 IF (A) = '0' TO '9'
CHRGOT = $B7 ;AS ABOVE - BUT DON'T INC TXTPTR.
TXTPTR = $B8 ;PTR ($B8,$B9) TO NEXT BYTE OF
;PRGM TEXT.
CHRGTRTN = $C8 ;"RTS" AT END OF CHRGET/CHRGOT.
SPEEDFLG = $F1 ;# USED TO CTRL DELAY ($00-$FF).
TRCFLG = $F2 ;TRACE FLAG.
FLSHMSK = $F3 ;MASK FOR FLASHING OUTPUT.
;($40 FOR FLASH, ELSE $00).


*--------------------------------*
*       PAGES ONE TO EIGHT       *
*--------------------------------*

STACK = $100 ;TOP OF THE STACK.

BUF300 = $300 ;PAGE 3 - USED BY BOOT AS BUF TO
;STORE 2- & 6-ENCODED NIBBLES.
BTNIBL = $36C ;BOOT NIBBLE TABLE - USED TO
;TRANSLATE DISK BYTES TO ENCODED
;MEMORY BYTES.
SEC2RD08 = $800 ;DEFINES # OF SECS TO BE READ IN
;BY BOOT0.
BT1EXC08 = $801 ;START OF BOOT1.  BOOT0 JMPS TO
;THIS LOCATION.
SKPREL08 = $81F ;TARGET LABEL FOR BRANCH WHEN
;BOOT1 IS EXECUTING IN PAGE 8.
;- DETERMINE # OF SECS LFT 2 READ
;  IN, PHYS SEC # & TARGET ADR.
PRP4B208 = $839 ;TARGET LABEL FOR BRANCH WHEN
;BOOT1 IS EXECUTING IN PAGE 8.
;- PREPARE FOR BOOT2.


*--------------------------------*
*   DISK CONTROLLER CARD ADRS    *
*--------------------------------*
* NOTE:  THE DISK CONTROLLER ROMS
* ARE RELOCATABLE TO ANY PAGE
* BOUNDARY.  THE ACTUAL ADRS USED
* ARE DEPENDENT UPON WHICH SLOT
* (1 TO 7) HOUSES THE CONTROLLER
* CARD.  WHEREAS THESE SLOTS ARE
* REPRESENTED BY PAGES $C1 TO $C7,
* THE HI BYTE OF THE FOLLOWING
* ADRS CAN BE CHANGED TO $CS WHERE
* S=SLOT #.  THE SAMPLE ADRS GIVEN
* BELOW REFER TO A CARD IN SLOT6
* (PAGE $C6).  THE FUNCTIONS OF
* EACH OF THE FOLLOWING ROUTINES
* IS DESCRIBED IN THE FORMATTED
* DISASEMBLY TITLED "THE BOOT PROCESS".

BUILDTBL = $C606
TESTCARY = $C614
GETNEWX = $C61E
MAGNTOFF = $C63D
PRSRVFLG = $C65D
STARTSEQ = $C65E
BTRYD5 = $C663
BTRYAA = $C667
BTRY96 = $C671
BTRYAD = $C67D
RDVLTKSC = $C683
MOREBYTS = $C685
BTRDODD = $C687
BTRDEVEN = $C68F
BTRDATA = $C6A6
KEEPCNT1 = $C6A8
RDDSK1 = $C6AA
KEEPCNT2 = $C6BA
RDDSK2 = $C6BC
RDCK = $C6CB
TSTREAD = $C6D3
SETX56 = $C6D7
DOWNX = $C6D9


*--------------------------------*
*      APPLESOFT ADDRESSES       *
*--------------------------------*
* A BRIEF DESCRIPTION OF THE
* FUNCTIONS OF THESE ROUTINES ARE
* GIVEN BELOW.  NOTE THAT SOME OF
* THESE ROUTINES MAY BE INTERCEPTED
* BY DOS. (SEE FORMATTED DIS'MBLIES
* FOR DETAILS.)

ESTPTRS = $D4F5 ;RECALC LINK PTRS IN APPLESOFT
;PRGM IN CASE PRGM WAS NOT LOADED
;INTO THE SPACE AT WHICH IT WAS
;ORIGINALLY WRITTEN.
LOCEOP = $D4FE ;FIND END OF APPLESOFT PRGM.
STARTNXT = $D50F ;PUT NEW LINK IN FP PRGM LINE.
LOCEOL = $D511 ;FIND END OF APPLESOFT PRGM LINE.
INLIN = $D52C ;INPUT LINE OF TEXT IN2 INPUT BUF
;(WITHOUT PROMPT).
INLINPL2 = $D52E ;AS ABOVE, BUT USE VAL IN (X) AS
;PROMPT.
TERMIN8 = $D539 ;PUT AN END-OF-LINE MARKER (EOL,
;$00) IN INPUT BUFFER.
CNVRTPOS = $D541 ;CONVERT INPUT LINE TO POS ASCII.
NEG8NPUT = $D54C ;PREPARE TO INITIALIZE THE TEXT
;PTR.  (SET A=0, Y=01, X=FF.)
CLEAR = $D66A ;SIMULATE A CLEAR STATEMENT.
CLEARC = $D66C ;CLEAR VARIABLES & TEXT.
STKINI = $D683 ;REINTIALIZE STK POINTER WHILE
;PRESERVING RETURN ADDRESS.
CLRTS = $D696 ;"RTS" AT END OF STKINI ROUTINE.
SETXTPT = $D697 ;SET TEXT PTR TO BEGINNING OF THE
;APPLESOFT PRGM.
RESTORE = $D849 ;SIMULATE A RESTORE STATEMENT.
SETDA = $D853 ;RESET PTR 2 DATA STATEMENT BYTE.
CRDO = $DAFB ;PRINT A <CR>.
STRPRT = $DB3D ;PRT STRING WHICH HAS DESCRIPTOR
;POINTED TO BY $A0,$A1.
OUTQUES = $BD5A ;PRINT A "?".
OUTDO = $DB5C ;PRINT CONTENTS OF (A) AS CHAR.
GODOPUT = $BD64 ;PRINT (A) VIA COUT.
INPUT = $DBB2 ;PROCESS AN INPUT STATEMENT.
NOPTNSTR = $DBC4 ;PROCESS AN INPUT STATEMENT WITH
;NO OPTIONAL STRING PROMPT.
CKDIFRD = $DBC7 ;BYPASS PRINTING "?" WHEN USING
;ALTERNATE STRING PROMPT INSTEAD.
STRTXT = $DE81 ;PRINT THE STRING.
SYNCHR = $DEC0 ;CHK BYTE POINTED TO BY TXTPTR TO
;SEE IF IT MATCHES (A).  IF NOT,
;EXIT WITH SYNTAX ERROR.
IQERR = $E199 ;ILLEGAL QUANTITY ERROR.
WASDEF = $E2AC ;"RTS" ENCOUNTERED IF USING
;DEFERRED MODE WHEN PROCESSING AN
;INPUT STATEMENT.
ERRDIR = $E306 ;CHK IF IN DEFERRED OR IMMEDIATE
;MODE WHEN PROCESSING AN INPUT
;STATEMENT.
BSCOLDST = $F128 ;BEGIN BASIC'S COLDSTART SEQUENCE
MV2ZPG = $F152 ;COPY IMAGE OF CHRGET ROUTINE AND
;RANDOM # SEED TO PAGE ZERO. (BUG
;IN ROUTINE BECAUSE IT DOESN'T
;TRANSFER ALL OF RANDOM # SEED,)
NORMAL = $F273 ;SET NORMAL MODE.
INVERSE = $F277 ;SET INVERSE MODE.
NORMINV = $F279 ;SET INVERSE OR NORMAL MODE.
SETINV = $F27B ;STORE MASK 4 INVERSE IN INVFLG.


*--------------------------------*
*      MONITOR ROM ROUTINES      *
*--------------------------------*
* A BRIEF DESCRIPTION OF THE
* FUNCTIONS OF THESE ROUTINES ARE
* GIVEN BELOW.  NOTE THAT SOME OF
* THESE ROUTINES MAY BE INTECEPTED
* BY DOS. (SEE FORMATTED DIS'MBLIES
* FOR DETAILS.)

CLREOL = $FC9C ;CLR LINE FRM CURRENT CURSOR POSN
;(BASL),(CH) 2 RIGHT EDGE OF WNDW
CLEOLZ = $FC9E ;CLR LINE FRM CURRENT CURSOR POSN
;(BASL),Y 2 RIGHT EDGE OF WINDOW.
CLEOL2 = $FCA0 ;PUT CHAR IN (A) FROM (BASL),Y TO
;RIGHT EDGE OF WINDOW.
WAIT = $FCA8 ;MONITOR ROM'S MAIN DELAY ROUT'N.
;DEALY Z # OF CYCLES BASED ON THE
;FORMULA:Z=((5*A^2)+(27*A)+26))/2
;WHERE A = VALUE IN ACCUMULATOR.
WAIT2 = $FCA9 ;TARGET 4 BRANCH IN WAIT ROUTINE.
WAIT3 = $FCAA ;TARGET 4 BRANCH IN WAIT ROUTINE.
ESC = $FD2F ;HANDLE AN <ESC> KEY INPUT.
RDCHAR = $FD35 ;PUT INPUT CHAR IN (A).
NOTCR = $FD3D ;HNDL INPUT CHAR OTHER THAN <CR>.
NOTCR1 = $FD5F ;HNDL INPUT CHAR OTHER THAN <CR>,
;<BKSPC> OR <CANCEL>.
CANCEL = $FD62 ;CANCEL THE INPUT LINE.
GETLNZ = $FD67 ;PRINT A <CR>, PROMPT & THEN READ
;A LINE OF INPUT.
BCKSPC = $FD71 ;HANDLE A BACKSPACE ("<-").
NXTCHAR = $FD75 ;READ THE NEXT CHAR.
CAPTST = $FD7E ;MAKE CHR UPPERCASE IF NECESSARY.
ADDINP = $FD84 ;PUT (A) IN INPUT BUF.
CROUT = $FD8E ;PRINT <CR> THROUGH COUT.
INPRT = $FE8D ;SELECT INPUT PORT # (A).
OUTPRT = $FE97 ;SELECT OUTPOUT PORT # (A).
IOPRT = $FE9B ;TEST IF I/O PORT # IS ZERO.
IOPRT1 = $FEA7 ;SET ZERO-PAGE POINTER (X,X+1) TO
;POINT AT $FD--.
IOPRT2 = $FEA9 ;SET ZERO-PAGE POINTER (X,X+1) TO
;POINT AT $(A)(Y).
BELL = $FF3A ;RING WARNING BELL WHEN INPUT BUF
;IS JUST ABOUT FULL.
 -
