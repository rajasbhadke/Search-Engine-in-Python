*===================================
* INITIALIZE THE I/O HOOKS SO THAT
* DOS INTERCEPTS ALL INPUT & OUTPUT.
*===================================

* FOR INSTANCE, IF A ROUTINE ACCESSES
* "COUT: JMP (CSW)" THEN EXECUTION
* WILL ACTUALLY FLOW TO DOS'S
* OUTPUT ROUTINE (OPUTINCP, $9EBD).
* SIMILARLY, ANY ROUTINE THAT REFERS
* TO "RDKEY: JMP (KSW)" WILL ACTUALLY
* JUMP TO DOS'S INPUT ROUTINE
* (INPTINCP, $9E81).
*
* THE TRUE (IE. NORMAL) HOOKS ARE SAVED,
* EX.  KSW: KEYIN --> KSWTRUE: KEYIN.
*      CSW: COUT1 --> CSWTRUE: COUT1.
* THEN THE INTERCEPTS ARE SET AS FOLLOWS:
*      ADINPTCP: INPTINCP --> KSW: INPTINCP.
*      ADOPUTCP: OPUTINCP --> CSW: OPUTINCP.

* CHECK IF INPUT HOOK NEEDS TO BE RESET.
INITIOHK LDA KSW+1
 CMP ADINPTCP+1
 BEQ CKOUTHK ;INPUT HK ALREADY POINTS 2 DOS'S
;INPUT HNDLER SO GO CHK OUTPUT HK

* RESET INPUT HOOK TO POINT TO DOS.

 STA KSWTRUE+1 ;KSW: KEYIN --> KSWTRUE: KEYIN.
 LDA KSW
 STA KSWTRUE
 LDA ADINPTCP ;ADINPTCP:INPTINCP-->KSW:INPTINCP
 STA KSW
 LDA ADINPTCP+1
 STA KSW+1

* CHECK IF OUTPUT HOOK NEEDS TO BE RESET.

CKOUTHK LDA CSW+1
 CMP ADOPUTCP+1
 BEQ SETHKRTN ;OUTPUT HK ALREADY PTS TO DOS'S
;OUTPUT HANDLER, SO EXIT.

* RESET OUTPUT HOOK TO POINT TO DOS.

 STA CSWTRUE+1 ;CSW: COUT1 --> CSWTRUE: COUT1.
 LDA CSW
 STA CSWTRUE
 LDA ADOPUTCP ;ADOPUTCP:OPUTINCP-->CSW:OPUTINCP
 STA CSW
 LDA ADOPUTCP+1
 STA CSW+1
SETHKRTN RTS



*========================================
* DOS COMMAND TEXT TABLE ($A884 - $A908).
*========================================
* THE NAMES OF THE DIFFERENT DOS COMMANDS
* CAN READILY BE CHANGED BY ALTERING THE
* INFORMATION IN THIS TABLE.  IF YOU
* DECIDE TO MESS AROUND WITH THIS TABLE,
* BE SURE TO:
* - LET THE 1RST CMD CREATE A NEW FILE.
*   (FOR EXPLANATION, SEE FMXTNTRY
*   ROUTINE ($AAFD) IN LINEAR DIS'MBLY.)
* - AVOID CREATING NEW DOS CMD NAMES
*   THAT DUPLICATE BASIC CMD NAMES.
* - USE POSITIVE ASCII CHARS FOR ALL BUT
*   THE LAST CHAR OF EACH NAME.
* - ENTER THE LAST CHAR IN EACH NAME IN
*   NEGATIVE ASCII FORM.
* - SHIFT SUBSEQUENT NAMES TO KEEP ALL
*   CHARS CONTIGUOUS IF YOU CREATE
*   SHORTER NAMES.
* - DON'T EXPAND THE TABLE BEYOND $A908.
* - END THE TABLE WITH A $00 BYTE.
*========================================

CMDTXTBL DCI 'INIT' ;         ($A884 - $A887)
 DCI 'LOAD' ;         ($A888 - $A88B)
 DCI 'SAVE' ;         ($A88C - $A88F)
 DCI 'RUN' ;          ($A890 - $A892)
 DCI 'CHAIN' ;        ($A893 - $A897)
 DCI 'DELETE' ;       ($A898 - $A89D)
 DCI 'LOCK' ;         ($A89E - $A8A1)
 DCI 'UNLOCK' ;       ($A8A2 - $A8A7)
 DCI 'CLOSE' ;        ($A8A8 - $A8AC)
 DCI 'READ' ;         ($A8AD - $A8B0)
 DCI 'EXEC' ;         ($A8B1 - $A8B4)
 DCI 'WRITE' ;        ($A8B5 - $A8B9)
 DCI 'POSITION' ;     ($A8BA - $A8C1)
 DCI 'OPEN' ;         ($A8C2 - $A8C5)
 DCI 'APPEND' ;       ($A8C6 - $A8CB)
 DCI 'RENAME' ;       ($A8CC - $A8D1)
 DCI 'CATALOG' ;      ($A8D2 - $A8D8)
 DCI 'MON' ;          ($A8D9 - $A8DB)
 DCI 'NOMON' ;        ($A8DC - $A8E0)
 DCI 'PR#' ;          ($A8E1 - $A8E3)
 DCI 'IN#' ;          ($A8E4 - $A8E6)
 DCI 'MAXFILES' ;     ($A8E7 - $A8EE)
 DCI 'FP' ;           ($A8EF - $A8F0)
 DCI 'INT' ;          ($A8F1 - $A8F3)
 DCI 'BSAVE' ;        ($A8F4 - $A8F8)
 DCI 'BLOAD' ;        ($A8F9 - $A8FD)
 DCI 'BRUN' ;         ($A8FE - $A901)
 DCI 'VERIFY' ;       ($A902 - $A907)
 HEX 00 ;     ($A908)
;$00 BYTE DENOTES END OF TABLE.


*========================================
* TABLE OF ATTRIBUTES & VALID OPTIONS
* THAT ARE ASSOCIATED WITH EACH COMMAND.
*             ($A909 - $A940)
*========================================

* NOTE:  ANY ALTERATIONS TO THIS TABLE
* SHOULD BE DONE WITH A DEGREE OF CAUTION
* BECAUSE SEVERAL PARAMETERS ACQUIRE
* CERTAIN DEFAULT VALUES IN THE ACTUAL
* COMMAND-HANDLING ROUTINES.  WITH JUST
* A BIT OF INSPECTION OF THE HANDLING
* ROUTINES HOWEVER, YOU SHOULD BE ABLE TO
* SAFELY MAKE EXTENSIVE CHANGES IF YOU SO
* DESIRE.
*
* THIS TABLE IS INDEXED BY A VALUE
* CORRESPONDING TO THE PARSED DOS
* COMMAND.  TWO BYTES OF INFORMATION
* ARE ASSOC WITH @ CMD.  A SET BIT
* DENOTES THE FOLLOWING:
*
*       FIRST BYTE
* 7  6  5  4  3  2  1  0
* .  .  .  .  .  .  .  .
* .  .  .  .  .  .  .  ...CMD CAN CREATE NEW FILE IF FILE
* .  .  .  .  .  .  .     NOT FOUND.
* .  .  .  .  .  .  ......CMD RESTRICTED TO DEFERRED MODE.
* .  .  .  .  .  .........VALUE FOR MAXFILES REQUIRED.
* .  .  .  .  ............VALUE FOR PR# OR IN# REQUIRED.
* .  .  .  ...............2ND FILENAME NEEDED (RENAME CMD)
* .  .  ..................FILE NAME APPLICABLE TO CMD
* .  .                    (EXPECTED BUT NOT NECESSARILY
* .  .                    REQUIRED.)
* .  .................... DO DOS CMD EVEN IF NO NAME GIVEN
* ....................... INTERPRET AS BASIC CMD IF NO NAM

*       SECOND BYTE
* 7  6  5  4  3  2  1  0
* .  .  .  .  .  .  .  .
* .  .  .  .  .  .  .  ...A(DDRESS) PARAMETER ALLOWED.
* .  .  .  .  .  .  ......B(YTE) PARAMETER ALLOWED.
* .  .  .  .  .  .........R(ECORD) # OR R(EL FIELD POS'N)
* .  .  .  .  .           PARAMETER ALLOWED.
* .  .  .  .  ............L(ENGTH) PARAMETER ALLOWED.
* .  .  .  ...............S(LOT) PARAMETER ALLOWED.
* .  .  ..................D(RIVE) PARAMETER ALLOWED.
* .  .....................V(OLUME) PARAMETER ALLOWED.
* ........................C, I, OR O PARAMETER ALLOWED.

CMDATTRB HEX 2170 ;INIT      00100001 01110000
 HEX A070 ;LOAD      10100000 01110000
 HEX A170 ;SAVE      10100001 01110000
 HEX A070 ;RUN       10100000 01110000
 HEX 2070 ;CHAIN     00100000 01110000
 HEX 2070 ;DELETE    00100000 01110000
 HEX 2070 ;LOCK      00100000 01110000
 HEX 2070 ;UNLOCK    00100000 01110000
 HEX 6000 ;CLOSE     01100000 00000000
 HEX 2206 ;READ      00100010 00000110
 HEX 2074 ;EXEC      00100000 01110100
 HEX 2206 ;WRITE     00100010 00000110
 HEX 2204 ;POSITION  00100010 00000100
 HEX 2378 ;OPEN      00100011 01111000
 HEX 2270 ;APPEND    00100010 01110000
 HEX 3070 ;RENAME    00110000 01110000
 HEX 4070 ;CATALOG   01000000 01110000
 HEX 4080 ;MON       01000000 10000000
 HEX 4080 ;NOMON     01000000 10000000
 HEX 0800 ;PR#       00001000 00000000
 HEX 0800 ;IN#       00001000 00000000
 HEX 0400 ;MAXFILES  00000100 00000000
 HEX 4070 ;FP        01000000 01110000
 HEX 4000 ;INT       01000000 00000000
 HEX 2179 ;BSAVE     01000001 01111001
 HEX 2071 ;BLOAD     01000000 01110001
 HEX 2071 ;BRUN      01000000 01110001
 HEX 2070 ;VERIFY    00100000 01110000


*=================================
* OPTION CHARACTER SYMBOL TABLE.
*        ($A941 - $A94A)
* THESE CHARACTERS ARE FREQUENTLY
* CHANGED AS PART OF A PROTECTION
* SCHEME.
*=================================

OPTNTXT ASC "VDSLRBACIO"


*=================================
*      OPTIONS ISSUED TABLE
*         ($A94B - $A954)
*  A SET BIT IN THE FOLLOWING BIT
*  POSITIONS (OF CUMLOPTN) DENOTE
*  THE OPTIONS THAT WERE ISSUED
*  WITH THE COMMAND.
*=================================

OPTNISSD HEX 40 ;V(OLUME) PARAMETER.
 HEX 20 ;D(RIVE) PARAMETER.
 HEX 10 ;S(LOT) PARAMETER.
 HEX 08 ;L(ENGTH) PARAMETER.
 HEX 04 ;R(ECORD # OR R(EL FIELD POS'N).
 HEX 02 ;B(YTE) PARAMETER.
 HEX 01 ;A(DDRESS) PARAMETER.
 HEX C0 ;C(OMMAND).
 HEX A0 ;I(NPUT).
 HEX 90 ;O(UTPUT).


*=================================
*   TABLE OF VALID RANGES ASSOC
*   WITH EACH OPTION CHARACTER.
*         ($A955 - $A970)
*  (THESE VALUES ARE FREQUENTLY
*  CHANGED IN AN EFFORT TO
*  "ENCHANCE" DOS OR IMPLEMENT
*  A PROTECTION SCHEME.  FOR
*  EXAMPLE, THE UPPER RANGE ASSOC
*  WITH THE L-PARAMETER IS OFTEN
*  CHANGED TO ALLOW DOS TO HANDLE
*  LARGER FILES.
*=================================

OPTNRNG HEX 0000FE00 ;($A955 - $A958)  V: (0 - 254).
 HEX 01000200 ;($A959 - $A95C)  D: (1 - 2).
 HEX 01000700 ;($A95D - $A960)  S: (1 - 7).
 HEX 0100FF7F ;($A961 - $A964)  L: (1 - 32767).
 HEX 0000FF7F ;($A965 - $A968)  R: (0 - 32767).
 HEX 0000FF7F ;($A969 - $A96C)  B: (0 - 32767).
 HEX 0000FFFF ;($A96D - $A970)  A: (0 - 65535).


*==================================
* TEXT TABLE OF DOS ERROR MESSAGES.
*         ($A971 - $AA3E)
* NOTE THAT ONLY THE LAST CHARACTER
* OF EACH TEXT MESSAGE IS WRITTEN
* IN NEGATIVE ASCII FORM.  (THESE
* MESSAGES ARE FREQUENTLY ALTERED
* IN COMMERCIAL PROGRAMS.)
*==================================

;CORRESPONDING ERROR CODE & ADDRS
ERRTXTBL HEX 0D078D ;              0  ($A971 - $A973)
;<CR>, <BELL>, <CR>
 DCI 'LANGUAGE NOT AVAILABLE' ;1 ($A974  - $A989)
 DCI 'RANGE ERROR' ;          2&3 ($A98A - $A994)
;BAD FM OPCODE OR SUBCODE ELSE,
;ILLEGAL ARGUMENTS ISSUED 4 IN#,
;PR#, MAXFILES CMDS OR FOR A, B,
;R, L, S, D, V, C, I, OR O OPT'NS
 DCI 'WRITE PROTECTED' ;       4  ($A995 - $A9A3)
 DCI 'END OF DATA' ;           5  ($A9A4 - $A9AE)
 DCI 'FILE NOT FOUND' ;        6  ($A9AF - $A9BC)
 DCI 'VOLUME MISMATCH' ;       7  ($A9BD - $A9CB)
 DCI 'I/O ERROR' ;             8  ($A9CC - $A9D4)
 DCI 'DISK FULL' ;             9  ($A9D5 - $A9DD)
 DCI 'FILE LOCKED' ;          10  ($A9DE - $A9E8)
 DCI 'SYNTAX ERROR' ;         11  ($A9E9 - $A9F4)
 DCI 'NO BUFFERS AVAILABLE' ; 12  ($A9F5 - $AA08)
 DCI 'FILE TYPE MISMATCH' ;   13  ($AA09 - $AA1A)
 DCI 'PROGRAM TOO LARGE' ;    14  ($AA1B - $AA2B)
 DCI 'NOT DIRECT COMMAND' ;   15  ($AA2C - $AA3D)
 HEX 8D ;<CR>      NO CODE    ($AA3E)


*=================================
* TABLE OF OFFSETS TO THE ERROR
* MSG TEXT TABLE ($AA3F - $AA4E).
* (HACKERS OFTEN SWAP THESE BYTES
* AROUND SO ERRONEOUS ERROR MSGS
* WILL BE USED.)
*=================================

OFF2ERR HEX 00 ;ERROR CODE - 0
 HEX 03 ;           - 1
 HEX 19 ;           - 2
 HEX 19 ;           - 3
 HEX 24 ;           - 4
 HEX 33 ;           - 5
 HEX 3E ;           - 6
 HEX 4C ;           - 7
 HEX 5B ;           - 8
 HEX 64 ;           - 9
 HEX 6D ;           - 10
 HEX 78 ;           - 11
 HEX 84 ;           - 12
 HEX 98 ;           - 13
 HEX AA ;           - 14
 HEX BB ;           - 15


*=================================
*   DOS MAIN ROUTINE VARIABLES.
*         ($AA4F - $AA65)
*=================================

CURFNADR DS 2 ;PTS TO CURRENT FILENAME BUF
;(USUALLY PRIMFNBF, $AA75).
;(NORMALLY LOADED FROM FNAMBUFM
;$B5C3, IN FM PARM LIST).
CONDNFLG DS 1 ;STATUS FLAG:
;$00 = WARMSTART, $01 = READ
;$80 = COLDSTART, $C0 = A(RAM).
OPUTCOND DS 1 ;CHAR SWITCH OUTPUT CONDITION FLG
;  $00 = EVALUATE START OF INPUT
;        LINE.
;  $01 = GOT A DOS CTRL CHAR SO
;        COLLECT DOS COMMAND.
;  $02 = NOT A DOS CMD, SO JUST
;        PRT CHAR & RTN TO CALLER.
;  $03 = HANDLING INPUT OR GET
;        STATMENTS WHILE READING.
;  $04 = WRITING DATA TO DISK.
;  $05 = EVALUATE 1RST CHAR OF
;        DATA LINE READ FROM DSK.
;  $06 = IGNORE "?" PRMPT & RESET
;        TO CONDITION 0.
CSWTRUE DA COUT1 ;ADR OF TRUE OUTPUT HANDLER.
KSWTRUE DA KEYIN ;ADR OF TRUE INPUT HANDLER.
MXFILVAL HEX 0303 ;CURRENT # OF DOS BUFS IN CHAIN
;(SECOND BYTE IS IRRELEVANT).
STKSAVED DS 1 ;($AA59) 1RST STACK PTR SAV AREA.
;(P.S.  DON'T CONFUSE WITH THE
;2ND STK POINTER SAVE AREA KNOWN
;AS "STKSAV" ($B39B).
XSAVED DS 1 ;(X) SAVE AREA.
YSAVED DS 1 ;(Y) SAVE ARE.
ASAVED DS 1 ;(A) SAVE AREA.
NDX2INBF DS 1 ;INDEX TO CMD LINE IN INPUT BUF.
CIOCUMUL DS 1 ;MON/NOMON FLAG.
;CUMMULATIVE UPDATED RECORD OF
;C/I/O ARGUMENTS:
;    C=$40, I=$20, O=$10, IO=$30,
;    CO=$50, CI=$60, CIO=$70.
NDX2CMD DS 1 ;INDEX TO COMMAND.
LENADRBF DS 2 ;2-BYTE BUF USED 2 HOLD BLOAD ADR
;& LENGTH READ FROM DISK.
;(LEFT WITH LNGTH OF LAST BLOAD.)
NEXTCMD DS 1 ;CODE FOR PENDING COMMAND.
TEMPBYT DS 1 ;TEMPORARY STORAGE AREA.
NDX2OPTN DS 1 ;INDEX TO OPTION (USED TO INDEX
;OPTNTXT, OPTNISSD & OPTNRNG).
CUMLOPTN DS 1 ;HOLDS CUMMULTIVE RECORD OF
;OPTIONS PARSED ON CMD LINE.


*=================================
*   OPTION PARSED VALUES TABLE.
*        ($AA66 - $AA74)
* (CONTAINS A RECORD OF THE OPTION
* VALUES THAT WERE ISSUED WITH THE
* COMMAND.  SOME OF THESE BYTES
* ARE DEFAULTED TO NON-ZERO VALS.)
*=================================

VOLPRSD DS 2 ;PARSED VOLUME NUMBER.
DRVPRSD DS 2 ;PARSED DRIVE NUMBER.
SLOTPRSD DS 2 ;PARSED SLOT NUMBER.
LENPRSD DS 2 ;PARSED LENGTH VALUE.
RECPRSD DS 2 ;PARSED RECORD OR RELATIVE FIELD
;POSITION NUMBER.
BYTPRSD DS 2 ;PARSED BYTE VALUE.
ADRPRSD DS 2 ;PARSED ADDRESS PARAMETER.
MONPRSD DS 1 ;PARSED MON/NOMON CHR CODE VALS.


*==================================
*  NON-CHAIN FILE NAME BUFFERS.
*  (PS.  DON'T CONFUSE WITH THE
*  VARIOUS FILENAME BUFS ASSOC
*  WITH THE CHAIN OF DOS BUFFERS.)
*==================================

* PRIMARY FILE NAME BUFFER.

PRIMFNBF DS 30 ;($AA75 - $AA92)

* SECONDARY FILE NAME BUFFER.

SCNDFNBF DS 30 ;($AA93 - $AAB0)


*====================================
* MAIN ROUTINE CONSTANTS & VARIABLES.
*           ($AAB1 - $AAB7)
*====================================

MAXDFLT DS 1 ;DEFAULT VALUE FOR # OF DOS BUFS.
;(OFTEN ALTERED N COM'CIAL PRGMS)
DCTRLCHR HEX 84 ;DOS'S CTRL CHAR:
;         NORMALLY = CTRL-D, $84.
;(OFTEN CHNGD IN COM'CIAL PRGMS)
EXECFLAG DS 1 ;EXEC FLAG: $00 = NOT EXECING,
;(ELSE CONTAINS 1RST CHAR OF NAME
;OF EXEC FILE).
EXECBUFF DS 2 ;PTS TO EXEC FILE'S BUFFER.
ACTBSFLG DS 1 ;ACTIVE BASIC FLAG (INT=$00,
;A(ROM)=$40, A(RAM)=$80).
RUNTRUPT DS 1 ;RUN INTERCEPTED FLAG:
;$00 = RUN NOT INTECEPTED.
;NON-ZERO = RUN INTERCEPTED TO DO
;           A LOAD.


*=================================
*  TEXT OF THE WORD "APPLESOFT".
*         ($AAB8 - $AAC0)
*=================================

APLSFTXT ASC "APPLESOFT"


*=================================
* FILE MANAGER'S CONSTANTS TABLE.
*        ($AAC1 - $AAC8)
*=================================

ADRIOB DA IBTYPE ;PTS TO RWTS'S IOB. NOTE:THE $3E3
;VECTOR LOADS FROM ADRIOB.
ADRVTOC DA VTOCBUFF ;PTS TO VTOC SECTOR BUFFER.
ADRDIRBF DA DIRECBUF ;PTS TO DIRECTORY SECTOR BUFFER.
DOSNDPL1 DA $C000 ;PTS TO LAST BYTE OF DOS PLUS 1.


*======================================
* FILE MANAGER'S FUNCTION HNDLR ENTRY
* POINT TABLE ($AAC9 - $AAE4).
* (ALL ADDRS ARE 1 LESS THAN THE ACTUAL
* ENTRY POINT BECAUSE THE THE FUNCTIONS
* ARE ENTERED VIA A "STACK JUMP".)
*======================================

FMFUNCTB DA $B37F-1 ;NULL - EXIT WITH NO ERRORS.
 DA $AB22-1 ;FNOPEN-1
 DA $AC06-1 ;FNCLOSE-1
 DA $AC58-1 ;FNREAD-1
 DA $AC70-1 ;FNWRITE-1
 DA $AD2B-1 ;FNDELETE-1
 DA $AD98-1 ;FNCATLOG-1
 DA $ACEF-1 ;FNLOCK-1
 DA $ACF6-1 ;FNUNLOCK-1
 DA $AC3A-1 ;FNRENAME-1
 DA $AD12-1 ;FNPOSN-1
 DA $AE8E-1 ;FNINIT-1
 DA $AD18-1 ;FNERIFY-1
 DA $B37F-1 ;NULL - EXIT WITH NO ERRORS.


*====================================
* FILE MANAGER READ-SUBFUNCTION ENTRY
* POINT TABLE ($AAE5 - $AAF0).
* (P.S.  SUBFUNCTIONS EMPLOYING THE
* POSITION OPTION ARE AVAILABLE TO
* THE USER BUT NEVER CALLED BY DOS.)
*====================================

;SUBFUNCTION INDEX.
RDSUBTBL DA GOODFMXT-1 ;(0), EXIT.
 DA READONE-1 ;(1), READ ONE BYTE.
 DA READRNG-1 ;(2), READ A RANGE OF BYTES.
 DA PSNRDONE-1 ;(3), POSITION & READ ONE BYTE.
 DA PSNRDRNG-1 ;(4), POS'N & READ RNGE OF BYTES.
 DA GOODFMXT-1 ;(5), EXIT.


*=====================================
* FILE MANAGER WRITE SUBFUNCTION ENTRY
* POINT TABLE ($AAF1 - $AAFC).
* (P.S.  SUBFUNCTIONS EMPLOYING THE
* POSITION OPTION ARE AVAILABLE TO
* THE USER BUT NEVER CALLED BY DOS.)
*=====================================

;SUBFUNCTION INDEX.
WRSUBTBL DA GOODFMXT-1 ;(0), EXIT.
 DA WRITEONE-1 ;(1), WRITE ONE BYTE.
 DA WRITERNG-1 ;(2), WRITE A RANGE OF BYTES.
 DA PSNWRONE-1 ;(3), POSITION & WRITE ONE BYTE.
 DA PSNWRRNG-1 ;(4), POS'N & WRITE RNG OF BYTES.
 DA GOODFMXT-1 ;(5), EXIT.


*=========================================
* FILE MANAGER EXTERNAL ENTRY POINT.
* -NOTE: THE $3D6 VECTOR LOADS FROM HERE!!
* -ENABLES USER TO ACCESS FILE MANAGER
* FROM CUSTOM ASSEMBLY LANGUAGE ROUTINES.
*=========================================

FMXTNTRY CPX #0
 BEQ FMXTCMD ;ALLOW NEW FILE-SIMUL8 AN "INIT".
 LDX #02 ;REQUIRES OLD FILE (SIMUL8 LOAD).
FMXTCMD STX NDX2CMD ;SET INDEX TO COMMAND.


*=================================
*       FILE MANAGER PROPER.
*---------------------------------

FILEMGR TSX ;SAVE STK PTR SO WE CAN LATER RTN
 STX STKSAV ;TO AFTRFUNC ($A6AB) LOCATED IN
;THE FMDRIVER ROUTINE ($A6A8).
;(NOTE THAT APPEND CMD EMPLOYS
;THE RSETPTRS ROUTINE ($B6B3) TO
;RE-ADJUST STKSAV ($B39B) SO THAT
;EXECUTION ACTUALLY RETURNS TO
;AFTRCMD ($A6AB) LOCATED IN THE
;DOS CMD PARSING AND PROCESSING
;ROUTINES.)
 JSR RSTRFMWA ;COPY FM WRK BUF (IN DOS CHAIN) 2
;FM WRK AREA (NOT IN DOS CHAIN).
 LDA OPCODEFM ;CHK IF OPCODE IS LEGAL.
 CMP #13 ;(MUST BE LESS THAN 13.)
 BCS TOERROP ;OPCODE TOO LARGE - RANGE ERROR.
 ASL ;DOUBLE VAL OF OPCODE & PUT IT IN
 TAX ;(X) SO IT INDEXES TABLE OF ADRS.
 LDA FMFUNCTB+1,X ;STICK ADDRESS (MINUS 1) OF THE
 PHA ;FUNCTION HANDLER ON THE STACK
 LDA FMFUNCTB,X ;(HI BYTE FIRST).
 PHA
 RTS ;DO A STACK JMP TO THE FUNCTION'S
;ENTRY POINT.

TOERROP JMP RNGERROP ;GO HANDLE RANGE ERROR.


*=================================
*      OPEN FUNCTION HANDLER.
*=================================

FNOPEN JSR COMNOPEN ;OPEN PREEXISTING FILE OR CREATE
;NEW FILE IF CMD ALLOWS NEW FILES
 JMP GOODFMXT ;EXIT CLEANLY. EVENTUALLY RTNS TO
;AFTRFUNC ($A6AB) LOCATED IN THE
;FM DRIVER ROUTINE ($A6A8).


*=================================
*      COMMON OPEN ROUTINE.
*=================================

COMNOPEN JSR ZWRKAREA ;INITIALIZE THE FM WORK AREA WITH
;DEFAULT VALUES.
;(DON'T CONFUSE WITH FM WRK BUF
;WHICH IS IN DOS BUF CHAIN.)
 LDA #1 ;DESCRIBE SECTOR LENGTH AS 256
 STA SECSIZWA+1 ;BYTES (IN FM WORK AREA).

* GET RECORD LENGTH FROM FM PARM
* LIST & PUT IT IN FM WORK AREA.
* (DON'T ALLOW A 0 LENGTH.  IF
* ZERO, CHANGE IT TO ONE.)

 LDX RECLENFM+1
 LDA RECLENFM
 BNE STRECLEN ;NON-ZERO REC LENGTH IS OK.
 CPX #0
 BNE STRECLEN
 INX ;WAS ZERO, MAKE IT ONE INSTEAD.
STRECLEN STA RECLENWA ;PUT LENGTH IN FM WORK AREA.
 STX RECLENWA+1
 JSR GETFNTRY ;TRY 2 FIND DIRECTORY SEC 4 FILE.
 BCC FILLINWA ;BRNCH IF FOUND DIR SEC WITH SAME
;NAME IN FILE DESCRIPTION ENTRY.

* THE NAMED FILE WAS NOT FOUND IN
* THE DIRECTORY, SO PREPARE A NEW
* FILE ENTRY IN CASE THE CMD CAN
* LEGALLY CREATE A NEW FILE.

 STX CURDIRNX ;OFFSET TO NEW DESCRIP ENTRY IN
;CASE WANT TO CREATE A NEW FILE.

* CHECK TO SEE IF CMD CAN
* LEGALLY CREATE A NEW FILE.

 LDX NDX2CMD ;(X) = INDEX REPRESENTING CMD.
 LDA CMDATTRB,X ;GET 1RST BYTE CONTAINING DESCRIP
;OF THE COMMAND'S ATTRIBUTES.
 LDX CURDIRNX ;(X)=INDEX FOR A NEW FILE DESCRIP
;ENTRY INTO DIRECTORY SEC.
 LSR ;(C)=BIT0 OF 1RST ATTRIBUTE BYTE.
 BCS CREATNEW ;IF (C)=1 CMD CAN MAKE NEW FILE.

* COMMAND CAN'T CREATE NEW FILE.
* SEE WHICH LANGUAGE WE'RE USING
* & EXIT WITH APPROPRIATE ERROR.

NEWILLGL LDA CONDNFLG ;$00=WARMSTART, $01=READING,
;$40=A(RAM), $80=COLDSTART,
;$C0=INTEGER.
 CMP #$C0 ;IS INTEGER IN ROM?
 BNE TOFILNOT ;NO.
 JMP LNGNOTAV ;HANDLE LANGUAGE-NOT-AVAIL ERROR.

TOFILNOT JMP FILENOT ;HANDLE FILE-NOT-FOUND ERROR.


*---------------------------------
*  CREATE A NEW FILE:
*  - INIT FILE SIZE = 1 SEC LONG.
*  - ALLOCATE SECS FOR DATA SECS
*    & UPDATE FILE SIZE.
*  - WRITE UPDATED VTOC TO DISK.
*  - PUT LINK IN FILE DESCRIPTION
*    ENTRY & UPDATE FILE SIZE.
*  - WRITE UPDATED VTOC TO DISK.
*  - WRITE NEW T/S LIST TO DISK.
*--------------------------------

CREATNEW LDA #0 ;INITIALIZE FILE SIZE = 1 SECTOR.
 STA FIL1SIZE+1,X ;(CAUSE AT 1RST, ONLY STARTING
 LDA #1 ;OUT WITH A T/S LIST SECTOR.)
 STA FIL1SIZE,X
 STX CURDIRNX ;SAVE BYTE OFFSET INTO DIR SEC
;FOR FILE DESCRIPTION.
 JSR ASGNTKSC ;FIND TRK/SEC VALS FOR NEW FILE.

* FINISH SETTING UP PARAMETERS
* IN THE FILE MANAGER'S WORK AREA.
* (P.S. DON'T CONFUSE FM WORK AREA
* WITH THE VARIOUS WORK BUFFERS
* LOCATED IN THE DOS BUFFER CHAIN.)

 LDX CURDIRNX ;OFFSET IN DIR SEC 4 NEW DESCRIP
 STA FIL1TSSC,X ;PUT SEC VAL IN DIRECTORY SECTOR.
 STA FIRTSSEC ;PUT SEC VALUE OF 1RST T/S LIST
;SECTOR IN THE FM WORK AREA.
 STA CURTSSEC ;PUT CUR SEC VAL IN FM WRK AREA.
 LDA ASIGNTRK ;DO THE SAME FOR TRACK VALUE.
 STA FIL1TSTK,X
 STA FIRSTSTK
 STA CURTSTRK
 LDA FILTYPFM ;(FROM FM PARM LIST.)
 STA FIL1TYPE,X ;PUT FILE TYPE IN DIREC SEC BUF.

* WRITE DIRECTORY SECTOR BUFFER.

 JSR WRDIRECT ;WRITE DIRECTORY SEC BUF IN CAT.

* WRITE T/S LIST SECTOR BUFFER.

 JSR SELTSBUF ;GET ADR OF T/S LIST SEC BUF FROM
;THE FM PARM LIST.
 JSR ZCURBUF ;ZERO OUT T/S LIST SECTOR BUF.
 JSR WRITETS ;WRITE ZEROED OUT T/S LIST SEC.
;(IF THE WRITE SUBFUNCTION IS
;LATER ENTERED TO WRITE NEW DATA
;TO THE DISK, THE ZERO BYTES ARE
;DETECTED & USED AS SIGNALS THAT
;NEW DATA PAIR SHOULD BE WRITTEN
;INTO THE T/S LIST SECTOR.)
 LDX CURDIRNX ;OFFSET IN DIREC SEC 4 NEW FILE.
 LDA #6 ;DEFAULT RETURN CODE VALUE 2 THAT
 STA RTNCODFM ;FOR A FILE-NOT-FOUND ERROR.

* FILL IN THE FM WORK AREA BUFFER.
* (ROUTINE COMMON TO OPENING A
* NEW OR PRE-EXISTING FILE.)

FILLINWA LDA FIL1TSTK,X ;T/S LIST TRK (FRM DIRECTORY SEC)
 STA FIRSTSTK
 LDA FIL1TSSC,X ;T/S LIST SEC (FRM DIRECTORY SEC)
 STA FIRTSSEC
 LDA FIL1TYPE,X ;FILE TYPE (FROM DIRECTORY SEC).
 STA FILTYPFM
 STA FILTYPWA
 LDA FIL1SIZE,X ;FILE SIZE (FROM DIRECTORY SEC).
 STA FILENSEC
 LDA FIL1SIZE+1,X
 STA FILENSEC+1
 STX BYTNXD1R ;INDEX IN2 DIREC SEC FOR DESCRIP.
 LDA #$FF ;PRETEND THAT THE LAST DATA SEC
 STA RELPREV  ;USED HAD A RELATIVE SECTOR #
 STA RELPREV+1 ;(IN RELATION TO THE ENTIRE FILE)
;OF #$FFFF.  NOTE: THIS VALUE IS
;LATER USED TO TRICK THE READ AND
;WRITE SUBFUNCTIONS INTO IGNORING
;THE DATA SECTOR CURRENTLY IN
;MEMORY.
 LDA MXIN1TSL ;DICTATE THAT A T/S LIST CAN ONLY
 STA MXSCURTS ;DESCRIBE $7A (#122) DATA SECS.
;NOTE: THIS VAL IS LATER USED BY
;THE READ AND WRITE SUBFUNCTIONS
;TO DECIDE WHETHER OR NOT THE T/S
;LIST CURRENTLY IN MEMORY SHOULD
;BE USED.

* READ FIRST T/S LIST SECTOR TO
* THE T/S LIST SEC BUFFER.
* (EVENTHOUGH IT IS NOT NEEDED BY
* THE RENAME, LOCK OR UNLOCK
* FUNCTIONS, THE FIRST T/S LIST IS
* AUTOMATICALLY READ INTO THE T/S
* LIST BUFFER IF THE FILE WAS
* FOUND.)

 CLC ;(C)=0 =SIGNAL 1RST T/S LIST SEC.
 JMP READTS ;GO READ IN THE T/S LIST SEC.


*==================================
* INITIALIZE (IE. ZERO OUT) THE FM
* WORK AREA SO IT CAN BE CUSTOMIZED
* IN ACCORDANCE WITH THE CALLING
* FUNCTION.  (ALTHOUGH SOME WORK
* BYTES MAY NOT BE SUBSEQUENTLY
* ALTERED, DON'T BE LULLED INTO
* THINKING THAT THEY ARE NOT
* IMPORTANT.  ZERO VALUES ARE JUST
* AS RELEVANT AS NON-ZERO VALUES.
* ALSO BE CAUTIONED NOT TO CONFUSE
* THE FM WORK AREA WITH ITS IMAGE
* (DOS WORK BUFFER) THAT IS HOUSED
* IN THE CHAIN OF DOS BUFFERS.)
*==================================

* ZERO OUT THE FM WORK AREA.

ZWRKAREA LDA #0
 TAX ;INITIALIZE X-INDEX.
ZEROWRKA STA FMWKAREA,X ;PUT $00 BYTE IN WORK AREA.
 INX
 CPX #45 ;WORK AREA IS 45 BYTES LONG.
 BNE ZEROWRKA

* BEGIN CUSTOMIZING THE WORK AREA.
* GET VOL, DRV, SLOT & CATALOG TRK
* VALUES FROM THE FM PARM LIST.
* PUT DRV, SLOT*16, CAT TRK AND
* COMPLEMENTED VOL # IN THE WORK
* AREA.

 LDA VOLFM ;VOLUME #.
 EOR #$FF ;CALC 1'S COMPLEMENT OF VOL #.
 STA VOLWA
 LDA DRVFM ;DRIVE #.
 STA DRVWA
 LDA SLOTFM ;GET SLOT #.
 ASL ;CALC SLOT * 16.
 ASL
 ASL
 ASL
 TAX ;SET (X) = SLOT*16.
 STX SLOT16WA
 LDA #$11 ;NORMAL CAT TRK = #17.
 STA TRKWA
 RTS


*=================================
*     CLOSE FUNCTION HANDLER.
*=================================

FNCLOSE JSR CKDATUP ;WRITE DATA SEC BUF IF NECESSARY.
 JSR CKTSUPDT ;WRITE T/S LIST SEC BUF IF NEC.
 JSR FIXMAP ;FREE UP SECS THAT WERE ALLOCATED
;BUT NOT USED. WHENEVER SOMETHING
;IS WRITTEN 2 THE DISK, THE WHOLE
;TRK IS ALLOCATED IN THE VTOC
;WHETHER IT IS NEEDED OR NOT.
;THERE4, ONCE DONE WRITING, GO
;BACK & FREE UP UNNEEDED SECS.

* WAS LAST OPERATION A WRITE?

 LDA #%00000010 ;IF BIT 1 SET, THEN WAS WRITE.
 AND UPDATFLG
 BEQ TOGDFMXT ;WASN'T A WRITE SO CAN JUST EXIT
;CAUSE NO NEED TO UPDATE DIR SEC.

* LAST OPERATION WAS A WRITE, SO
* BETTER PREPARE TO FIX UP THE
* FILE-SIZE BYTES AND T/S LINKS
* IN DIRECTORY SECTORS, ETC.

 JSR READVTOC ;READ VOLUME TABLE OF CONTENTS.

* READ IN ALL DIR SECS UP TO THE
* ONE CONTAINING THE FILE DESCRIP
* ENTRY FOR THE FILE WE ARE CLOSING.

 LDA #0
 CLC ;(C)=0=SIGNAL 2 READ 1RST DIR SEC
PURGEDIR JSR RDDIRECT ;GO READ A DIRECTORY SEC.
 SEC ;(C)=1, 1RST DIR SEC ALREADY READ
 DEC SECNXD1R ;INDEX FOR # OF DIRECTORY SECS.
 BNE PURGEDIR ;IF 0, THEN JUST READ DIREC SEC
;PERTAINING TO THE FILE WANTED.

* UPDATE THE FILE SIZE & WRITE THE
* DIRECTORY SECTOR TO THE DISK.

 LDX BYTNXD1R ;(X) = OFFSET OF FILE DESCRIPTION
;IN THE DIRECTORY SECTOR.
 LDA FILENSEC ;# SECS IN FILE (FRM FM WRK AREA)
 STA FIL1SIZE,X
 LDA FILENSEC+1
 STA FIL1SIZE+1,X
 JSR WRDIRECT ;WRITE UPDATED DIRECTORY SECTOR.

TOGDFMXT JMP GOODFMXT ;CLEAN EXIT.  EVENTUALLY RTNS TO
;AFTRFUNC ($A6AB) LOCATED IN THE
;FMDRIVER ROUTINE ($A6A8).


*=================================
*     RENAME FUNCTION HANDLER.
*=================================

FNRENAME JSR COMNOPEN ;LOCATE FILE WITH SAME NAME & OPN
;IT IF ITS NOT ALREADY OPEN.
 LDA FILTYPWA ;GET FILE TYPE (FROM WORK AREA).
 BMI TOFILOCK ;ERROR-CAN'T RENAME A LOCKED FILE
 LDA RENAMBUF ;GET ADR OF SECONDARY NAME BUFFER
 STA A4L ;FROM FM PARM LIST & PUT IN A4L/H
 LDA RENAMBUF+1
 STA A4L+1
 LDX CURDIRNX (X) = INDEX INTO CURRENT DIR SEC.
 JSR NWDESCRP ;COPY NEW NAME TO DIREC SEC BUF.
 JSR WRDIRECT ;WRIT MODIFIED DIR SEC BUF 2 DSK.
 JMP GOODFMXT ;TAKE THE GOOD ROUTE HOME.
;EVENTUALLY RETURNS TO AFTRFUNC
;LOCATED IN FMDRIVER RTN ($A6A8).
 F
